<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术闲谈</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-26T14:05:51.710Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>茂松</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最大熵模型</title>
    <link href="http://yoursite.com/2019/03/23/ML-MaxEntropy/"/>
    <id>http://yoursite.com/2019/03/23/ML-MaxEntropy/</id>
    <published>2019-03-23T13:44:38.000Z</published>
    <updated>2019-03-26T14:05:51.710Z</updated>
    
    <content type="html"><![CDATA[<p><a href="">GitHub</a><br><a href="https://www.jianshu.com/p/b5c57b80ee5f" target="_blank" rel="noopener">简书</a><br><a href="https://blog.csdn.net/u014630987/article/details/88831663" target="_blank" rel="noopener">CSDN</a></p><h1 id="1-最大熵原理"><a href="#1-最大熵原理" class="headerlink" title="1. 最大熵原理"></a>1. 最大熵原理</h1><p>最大熵模型（Maximum Entropy Model)是通过最大熵原理推导实现,那什么是最大熵原理？</p><p>熵是随机变量不确定性大的度量，不确定性越大，熵值越大；若随机变量变为定值，即某个值发生的概率为1，而其它事件都为0， 此时熵值为0，均匀分布是熵值最大的分布，也即“最不确定的分布”。</p><p>假设离散随机变量 $X$ 的概率分布是 $P(X)$,则其熵为:</p><script type="math/tex; mode=display"> H(P)=-\sum_{x}p(x)logp(x) \tag{1}</script><p>熵满足如下条件:</p><script type="math/tex; mode=display">0 \leq H(P) \leq log|X|</script><p>其中,$|X|$ 表示 $X$ 的取值，当 $X$ 的分布是均匀分布时，满足左边等号，当 $X$ 是确定事件时，满足左边的等号。</p><p>从上面可知，最大熵原理认为该求解的概率模型满足如下条件:</p><ol><li>满足事先已约束的条件；</li><li>然后在满足这些条件的模型中选择熵最大的模型，即让不确定的信息等可能的发生；</li></ol><h1 id="2-最大熵模型"><a href="#2-最大熵模型" class="headerlink" title="2. 最大熵模型"></a>2. 最大熵模型</h1><p>将最大熵原理应用到分类问题中即得到最大熵模型。假设分类模型的一个条件概率分布 $P(Y|X)$, $X\in\chi\subseteq R^n$ 表示输入，$X\in\gamma$表示输出。这个模型表示给定的输入 $X$,以条件概率$P(Y|X)$输出$Y$。</p><p>给定一个训练数据集</p><script type="math/tex; mode=display">T=\{(x_1, y_1), (x_2,y_2)...(x_N, y_N)\}</script><p>学习的目标是用最大熵原理选择最好的模型。</p><p>对于给定训练数据集，我们可以确定联合分布$P(X, Y)$的经验分布$\tilde P(X,Y)$和边缘分布 $P(X)$ 的经验分布 $\tilde P(X)$,即：</p><script type="math/tex; mode=display">\tilde P(X=x, Y=x) = \frac{v(X=x, Y=y)}{N} \\\tilde P(X=x) = \frac{X(X=x)}{N}\tag{2}</script><p>其中，$v(X=x, Y=y)$ 表示训练数据中样本$(x, y)$出现的频数， $V(X=x)$表示训练数据集中 $x$ 出现的频数。 $N$ 表示训练样本的总容量。</p><p><strong>特征函数$f(x, y)$</strong> 表示输入 $x$ 和输出$y$ 之间的某个约束。其定义为:</p><script type="math/tex; mode=display">f(x,y)=\begin{cases}    1,\quad x和y满足约束\\    0, \quad x和y不满足约束\end{cases}\tag{3}</script><p>特征函数 $f(x,y)$ 关于经验分布 $\tilde P(X, Y)$的期望值为:</p><script type="math/tex; mode=display">E_{\tilde p}(f) = \sum_{x, y} \tilde P(x,y)f(x, y)\tag{4}</script><p>特征函数 $f(x,y)$ 关于模型 $P(Y|X)$ 和经验分布 $\tilde P(X)$的期望值为:</p><script type="math/tex; mode=display">E_{p}(f) = \sum_{x, y} \tilde P(x)P(y|x)f(x, y)\tag{5}</script><p>因为机器学习的目的就是从数据集中学得数据中包含的某种内在信息，因此我们可以假设公式4和公式5相等，即</p><script type="math/tex; mode=display">E_{\tilde p}(f) = E_{p}(f) \\\sum_{x, y} \tilde P(x,y)f(x, y) = \sum_{x, y} \tilde P(x)P(y|x)f(x, y)\tag{6}</script><p>公式6就作为模型的约束条件，如果有 n 个特征函数，则就有 n 个约束条件。</p><p><strong>最大熵模型</strong> 假设满足所有约束条件的模型集合为</p><script type="math/tex; mode=display">C=\{P|E_{\tilde p}(f_i) = E_{p}(f_i), i=1,2...n\}</script><p>定义在条件概率分布 $P(Y|X)$ 上的条件熵为:</p><script type="math/tex; mode=display">H(P) = - \sum_{x,y}\tilde P(x)P(y|x)logP(y|x)\tag{7}</script><p>则模型集合 $C$ 条件熵最大的模型成为<strong>最大熵模型</strong></p><p><strong>补充</strong></p><p>条件概率的熵的公式为</p><script type="math/tex; mode=display">H(y|x)=-\sum_{x,y}p(x,y)logp(y|x)\tag{8}</script><p>因此最大熵模型如公式7所示。</p><p>总之，最大熵模型就是在满足约束的模型集合中选择条件概率分布 $P(Y|X)$ 最大的模型。</p><h1 id="3-最大熵模型的学习"><a href="#3-最大熵模型的学习" class="headerlink" title="3. 最大熵模型的学习"></a>3. 最大熵模型的学习</h1><p>通过上述上述的描述，最大熵模型可以形式化为约束最优化问题，即</p><script type="math/tex; mode=display">\max_{P \in C} H(P) = -\sum_{x,y}\tilde P(x)P(y|x)\log P(y|x) \\s.t. \quad E_{\tilde p}(f_i) = E_{p}(f_i), \quad i=1, 2...,n \\\quad \sum_yP(y|x) = 1\tag{9}</script><p>按照优化习惯，通常将最大值优化转换为最小值优化。即</p><script type="math/tex; mode=display">\max_{P \in C} -H(P) = \sum_{x,y}\tilde P(x)P(y|x)\log P(y|x) \\s.t. \quad E_{\tilde p}(f_i) = E_{p}(f_i), \quad i=1, 2...,n \\\quad \sum_yP(y|x) = 1\tag{10}</script><p>公式10所得出的解就是最大熵模型学习的模型。</p><p>解决上述约束最优化问题，我们通过拉格朗日对偶性来进行解决。</p><p>首先我们引入拉格朗日乘子$w_0, w_1,w_2…w_n$,定义拉格朗日函数 $L(p, w)$为</p><script type="math/tex; mode=display">    \begin{aligned}        L(P, w) &=-H(P) + w_0(1-\sum_yP(y|x))+\sum_{i=1}^{n}w_i(E_{\tilde p}(f_i) - E_{p}(f_i)) \\        &=\sum_{x,y}\tilde P(x)P(y|x)\log P(y|x) + w_0(1-\sum_yP(y|x)) \\        &+\sum_{i=1}^{n}w_i(\sum_{x,y}\tilde P(x,y)f(x, y) - \sum_{x, y} \tilde P(x)P(y|x)f(x, y))    \end{aligned}    \tag{11}</script><p>因此，最优化问题的原始问题为</p><script type="math/tex; mode=display">\min_{P\in C} \max_{w} L(P,w)\tag{12}</script><p>对偶问题</p><script type="math/tex; mode=display">\max_{w} \min_{P\in C}  L(P,w)\tag{13}</script><p>我们称公式10、11和12为原始问题，公式13为原始问题的对偶问题，且原始问题的解与对偶问题的解是等价的，因此，公式11的解就是我们求解的模型。</p><p>我们首先求解对偶问题公式13内部的极小化问题$\min_{P\in C}  L(P,w)$,该函数是关于 $w$ 的函数，我们将其记作:</p><script type="math/tex; mode=display">\psi (w) = \min_{P\in C}  L(P,w) = L(P_w, w)\tag{14}</script><p>$\psi (w)$ 称为对偶函数，同时其解记为:</p><script type="math/tex; mode=display">P_w = \arg \min_{p}L(P,w) = P_w(y|x)\tag{15}</script><p>我们可以利用偏导数来求解公式15，即</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial L(P,w)}{\partial P(y|x)} &= \sum_{x,y}(\tilde P(x) \log P(y|x) + \tilde{P}(x)) -\sum_{y}w_o+\sum_{i=1}^{n}w_i(-\sum_{x,y}\tilde{P}(x)f_{i}(x,y)) \\&= \sum_{x,y}\tilde{P}(x)(\log P(y|x) + 1) - \sum_{y}w_0-\sum_{x,y}{\tilde{P}(x)\sum_{i=1}^nw_if_i(x,y)} \\&=\sum_{x,y}\tilde{P}(x)(\log P(y|x) + 1) - \sum_x \tilde{P}(x)\sum_{y}w_0-\sum_{x,y}{\tilde{P}(x)\sum_{i=1}^nw_if_i(x,y)} \\&= \sum_{x,y}\tilde{P}(x)(\log P(y|x) + 1-w_0-\sum_{i=1}^nw_if_i(x,y))\end{aligned}\tag{16}</script><p>由于 $L(P,w)$是凸函数，我们我可令上式偏导数为0，在$\tilde P(x)&gt;0$的情况下，即可求出$P(y|x)$, 即：</p><script type="math/tex; mode=display">\begin{aligned}    P(y|x) &=\exp(\sum_{i=1}^{n}w_if_i(x,y)+w_0-1)\\        &=\frac{\exp{\sum_{i=1}^{n}w_if_i(x,y)}}{\exp(1-w_0)}\end{aligned}\tag{17}</script><p>由于在概率论中，$\sum_{y}P(y|x)=1$,因此需对公式17进行归一化，又$\exp(1-w_0)$为常数,因此：</p><script type="math/tex; mode=display">P_w(y|x)=\frac{1}{Z_w(x)}\exp(\sum_{i=1}^{n}w_if_i(x,y))\tag{18}</script><p>其中</p><script type="math/tex; mode=display">Z_w(x)=\sum_{y}\exp(\sum_{i=1}^nw_if_i(x,y))\tag{19}</script><p>公式18、19表示的模型就是最大熵模型$P_w=p_w(y|x)$.然后求解对偶函数的极大化问题</p><script type="math/tex; mode=display">\max_{w} \psi (w) \tag{20}</script><p>求得$w^*$,得到最终模型。</p><h1 id="4-极大似然估计"><a href="#4-极大似然估计" class="headerlink" title="4 极大似然估计"></a>4 极大似然估计</h1><p>通过上面一小节的计算，我们已经求出最大熵模型，但是此时该模型还是一个关于 $w$ 的函数，我们如何求出 $w$ 来求得最终的模型呢。</p><p>我们先来描述对数似然函数，通过前面一章的逻辑回归模型中的<a href="https://ranmaosong.github.io/2019/03/18/ML-ligistic-regression/" target="_blank" rel="noopener">最大似然估计</a>，我们可知对数似然函数和熵在值上互为相反数，又通过公式8得知条件概率的熵形式，因此我们可以得知，条件概率分布$P(Y|X)$的对数似然函数</p><script type="math/tex; mode=display">    L_{\tilde P}(P_w) = \sum_{x,y}\tilde{P}(x,y)\log P(y|x)    \tag{21}</script><p>我们再冲似然函数的定义方面证明上述公司的正确性。</p><p>在给定数据集$\{(x_1,y_1),(x_2,y_2)…(x_n,y_n)\}$,我们可求得当前模型的似然函数为:</p><script type="math/tex; mode=display">L(\theta)=\prod_{i=1}^n P(x_i, \theta)\tag{22}</script><p>我们假设$X_i$在训练集中出现了$C(x_i)$,因此公式22可以转化为:</p><script type="math/tex; mode=display">L(\theta)=\prod_{i=1}^k P(x_i, \theta)^{C(x_i)}\tag{23}</script><p>$k$ 表示训练数据集中总共有 k 种不同的输入特征，我们对上市求其 $\frac{1}{n}$次方，得：</p><script type="math/tex; mode=display">L(\theta)^{\frac{1}{n}}=\prod_{i=1}^k P(x_i, \theta)^{\frac{C(x_i)}{n}}\tag{24}</script><p>对公式24求对数的:</p><script type="math/tex; mode=display">\begin{aligned}  \log L(\theta)^{\frac{1}{n}} &=\log \prod_{i=1}^k P(x_i, \theta)^{\frac{C(x_i)}{n}}  \\  &= \sum_{i=1}^k \frac{C(x_i)}{n} \log P(x_i, \theta)\\\end{aligned}\tag{25}</script><p>因此对于$\log L(\theta)^{\frac{1}{n}}$ 和 $\log L(\theta)$是等价的，</p><p>因此对于条件概率分布$P(Y|X)$的对数似然函数</p><script type="math/tex; mode=display">    L_{\tilde P}(P_w) = \sum_{x,y}\tilde{P}(x,y)\log P(y|x)    \tag{26}</script><p>对于公式21-26的推导，不具有严格的树学理论，只是为了理解下面公式27做铺垫。</p><p>一直训练数据的经验概率分布$\tilde P(X,Y),$条件概率分布$P(Y|X)$的对数似然函数表示为</p><script type="math/tex; mode=display">\begin{aligned}    L_{\tilde P}(P_w) &=\log \prod_{xy}P(y|x)^{\tilde P(x,y)} = \sum_{x,y}\tilde{P}(x,y)\log P(y|x)\end{aligned}\tag{27}</script><p>将公式18和19带入公式27可得:</p><script type="math/tex; mode=display">\begin{aligned}    L_{\tilde P}(P_w) &=\sum_{x,y}\tilde{P}(x,y)(\sum_{i=1}^{n}w_if_i(x,y)-\log Z_w(x) \\    &=\sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^{n}w_if_i(x,y)-\sum_{x,y}\tilde{P}(x,y)\log Z_w(x) \\    &=\sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^{n}w_if_i(x,y)-\sum_{x}\tilde {P}(x)\log Z_w(x)\end{aligned}\tag{28}</script><p>公式28就是极大似然函数。上式最后两步最后一项的转化是因为 $Z_w(x)$ 是关于 x 的函数，所以可以对 $\tilde{P}(x,y)$ 对 $x$ 进行累加得到 $\tilde {P}(x)$.</p><p>我们再看看对偶函数 $\psi (w)$,我们将 $P_w(y|x)$ 带入公式11得:</p><script type="math/tex; mode=display">\begin{aligned}    \psi (w) =& \sum_{x,y}\tilde P(x)P_w(y|x)\log P_w(y|x) + w_0(1-\sum_yP(y|x)) \\        &+\sum_{i=1}^{n}w_i(\sum_{x,y}\tilde P(x,y)f(x, y) - \sum_{x, y} \tilde P(x)P_w(y|x)f(x, y)) \\        =&\sum_{x,y}\tilde P(x)P_w(y|x)\log P_w(y|x)  \\        &+\sum_{i=1}^{n}w_i(\sum_{x,y}\tilde P(x,y)f(x, y) - \sum_{x, y} \tilde P(x)P_w(y|x)f(x, y)) \\        =& \sum_{x,y}\tilde P(x,y)\sum_{i=1}^{n}w_if(x, y)+\sum_{x,y}\tilde{P}(x)P_w(y|x)(\log P_w(y|x)-\sum_{i=1}^{n}w_if_i{(x,y)}) \\        =& \sum_{x,y}\tilde P(x,y)\sum_{i=1}^{n}w_if(x, y)-\sum_{x,y}\tilde{P}(x)P_w(y|x)\log Z_w(x) \\        =& \sum_{x,y}\tilde P(x,y)\sum_{i=1}^{n}w_if(x, y)-\sum_{x,y}\tilde{P}(x)\log Z_w(x)\end{aligned}\tag{29}</script><p>公式29第三步到第四步用到下面公式进行推导:</p><script type="math/tex; mode=display"> P_w(y|x)=\frac{1}{Z_w(x)}\exp(\sum_{i=1}^{n}w_if_i(x,y)) \Rightarrow \log P_w(y|x)=\sum_{i=1}^{n}w_if_i(x,y)-\log Z_w(x)</script><p>倒数第二步到最后一步的推导用到了 $\sum_{y}P(y|x)=1$.</p><p>比较公式公式28和公式29，可得:</p><script type="math/tex; mode=display">\psi (w) = L_{\tilde P}(P_w)</script><p>因此，可以证明，最大熵模型学习中的对偶函数极大化等价于最大熵模型的极大似然估计。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;&quot;&gt;GitHub&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/b5c57b80ee5f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简书&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>逻辑(斯谛)回归(Logistic Regression)</title>
    <link href="http://yoursite.com/2019/03/18/ML-ligistic-regression/"/>
    <id>http://yoursite.com/2019/03/18/ML-ligistic-regression/</id>
    <published>2019-03-18T06:14:13.000Z</published>
    <updated>2019-03-21T14:21:47.653Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ranmaosong.github.io/2019/03/18/ML-ligistic-regression/" target="_blank" rel="noopener">GitHub</a><br><a href="https://www.jianshu.com/p/9f723c2ac52e" target="_blank" rel="noopener">简书</a><br><a href="https://blog.csdn.net/u014630987/article/details/88687924" target="_blank" rel="noopener">CSDN</a></p><p>在我们学习机器学习的过程中，我们所需解决的问题，大致可以分为两部分：分类和回归.其中,分类是指模型用来预测一个有限的离散值集合中的一个，比如猫狗分类，肿瘤的恶性或良性; 回归是指模型的输出是一个连续变量，比如预测房价、身高等.本篇内容讲解的是机器学习中经典的逻辑(斯谛)回归（Logistic Regression)，从名字上看，大家误以为该方法是一种回归方法，其实不然，它是分类方法的一种，常用于二元分类，但是为什么会取名回归，我个人理解大致有如下几点原因：</p><pre><code>1. 利用回归的思想来解决分类问题;2. 它的输出也是一个连续值，通过设定阈值来实现分类 </code></pre><h1 id="1-逻辑斯谛分布"><a href="#1-逻辑斯谛分布" class="headerlink" title="1. 逻辑斯谛分布"></a>1. 逻辑斯谛分布</h1><p><strong>定义</strong>：设X是连续随机变量，X服从逻辑斯谛分布是指X具有下列分布函数和密度函数：</p><script type="math/tex; mode=display">    F(x)=P(X \leq x)=\frac{1}{1+e^{-(x-u)/\gamma}} \tag{1}</script><script type="math/tex; mode=display">    f(x)=F^{'}(x)=\frac{e^{-(x-\mu)\gamma}}{\gamma(1+e^{-(x-u)/\gamma})^2} \tag{2}</script><p>其中,$\mu$为位置参数,$\gamma &gt; 0$为形状参数.</p><p>该函数以点$(\mu, \frac{1}{2})$为中对称，既有如下关系：</p><script type="math/tex; mode=display">\begin{aligned}F(-x+\mu) &= 1 - F(x+\mu)\\F(-x+\mu)-\frac{1}{2} &=  F(x + \mu) + \frac{1}{2}\end{aligned}\tag{3}</script><p>形状参数$\gamma$的值越小，曲线在中心附近增长的越快.该函数的图形如下图所示：</p><p><img src="/images/logistic_regression_sigmoid.png" alt="Sigmoid"><br>图一 逻辑斯谛分布的分布函数和密度函数</p><h1 id="2-二元逻辑斯谛回归"><a href="#2-二元逻辑斯谛回归" class="headerlink" title="2 二元逻辑斯谛回归"></a>2 二元逻辑斯谛回归</h1><p>二元逻辑斯谛回归模型是一种分类模型，有条件概率分布$P(Y|X)$表示，X取值为实数，随机变量 Y 取值为 1或0；</p><p><strong>逻辑斯谛回归模型</strong>的条件概率如下：</p><script type="math/tex; mode=display">\begin{aligned}    p(Y=1|x)&=\frac{exp(w\cdot x+b)}{1+exp(w\cdot x+b)}=\frac{1}{1+exp(-(w\cdot x+b))} \\    P(Y=0|x)&=\frac{1}{1+exp((w\cdot x+b))}\end{aligned}    \tag{4}</script><p>这里, $ x \in R^n $表示样本的特征向量，$Y \in {0, 1}$是输出表示样本的类别, $w \in R^n$ 和 $ b \in R$是模型的参数，其中，$w$ 表示权重向量,$b$表示偏置。$w \cdot x$表示$w$和$x$的内积.通常为了方便，我们将样本和权重向量进行扩充，仍记作$w$和$b$：</p><script type="math/tex; mode=display">w = (w^1, w^2... w^n, b)</script><script type="math/tex; mode=display">x = (x^1, x^2...x^n, 1)</script><p>此时逻辑斯蒂回归模型记作:</p><script type="math/tex; mode=display">\begin{aligned}    p(Y=1|x)&=\frac{exp(w\cdot x)}{1+exp(w\cdot x)} \\    P(Y=0|x)&=\frac{1}{1+exp((w\cdot x))}\end{aligned}\tag{5}</script><p><strong>几率</strong>是指一个事件发生与不发生的概率比值,即<br>$<br>\frac{p}{1-p}<br>$<br>则它的对数几率为$lnit(p)=log \frac{p}{1-p}$,对于逻辑斯蒂回归回归而言，其对数几率为</p><script type="math/tex; mode=display">logit(\frac{P(Y=1|x)}{1-P(Y=1|x)})=w \cdot x \tag{6}</script><h1 id="3-模型参数估计"><a href="#3-模型参数估计" class="headerlink" title="3 模型参数估计"></a>3 模型参数估计</h1><p>对于给定的训练数据集$T=\{(x_1, y_1), (x_2, y_2)…(x_n, y_x)\}$,可以应用极大似然估计(使模型预测的标签为真是标签的值最大化)模型参数，从而得到最优的逻辑斯蒂回归模型。</p><p>首先，设$P(Y=1|x)=\pi(x), P(Y=0|x)=1-\pi(x)$,则似然函数为:</p><script type="math/tex; mode=display">\begin{aligned}\prod_{i=1}^n[\pi(x)]^{y_i}[1-\pi(x)]^{1-y_i}=\prod_{i=1}^n{y_i\pi(x_i)+(1-y_i)(i-\pi(x_i))}\end{aligned}\tag{7}</script><p>极大似然函数和交叉熵的树学公式形式时一摸一样的，但是他们背后的数学原理略有不同。<br>通常在处理优化问题时，我们都利用对数函数来把连乘变成求和来简化问题，因此公式七的对数似然函数为：</p><script type="math/tex; mode=display">\begin{aligned}L(w) &= \sum_{i=1}^{n}[y_i ln \pi(x_i)+(1-y_i)ln(1-\pi(x_i))]\\    &=\sum_{i=1}^{n}[y_i ln \pi(x_i) - y_i ln(1-\pi(x_i)) + ln(1-\pi(x_i))] \\    &=\sum_{i=1}^{n}[y_iln\frac{\pi(x_i)}{1-\pi(x_i)}(注：这就是对数几率值）+ln(1-\pi(x_i))] \\    &=\sum_{i=1}^{n}[y_i(w*x_i)+ln(\frac{1}{1+exp((w\cdot x))})] \\    &=\sum_{i=1}^{n}[y_i(w*x_i)-ln(1+exp(w\cdot x_1))]\end{aligned}\tag{8}</script><p>通过梯度下降和拟牛顿法即可求的该函数，我们求$L(w)$对$w$的倒数:</p><script type="math/tex; mode=display">\begin{aligned}    \frac{\partial L(w)}{\partial w}&=\sum_{i=1}^{n}[y_ix_i-(\frac{1}{1+exp(w\cdot x_1)}*exp(w \cdot x_i)) * x_i]\\        &=\sum_{i=1}^{n}[y_ix_i-\pi(x_i)*x_i]\end{aligned}\tag{9}</script><p>通常我们在实际优化的时候，都是求取最小值，因此通常使用$-L(w)$作为损失函数.</p><p><strong>问题</strong>:在机器学习或深度学习中,我们通常以$L_2$作为损失函数，但是为什么这里是用了极大似然估计？</p><p>我们先观察一下使用$L_2$范数作为损失函数时，对$w$的求导公式:</p><script type="math/tex; mode=display">\begin{aligned}    L_2(w)&=\frac{1}{2}\sum_{i=1}^{n}(\pi(x_i) - y_i)^2 \\    \frac{\partial l_2(w)}{\partial w} &=\sum_{i=1}^{n}[(\pi(x_i) - y_i)*\frac{\partial\pi (x_i)}{\partial z} * \frac{\partial z}{\partial w}] \\    &=\sum_{i=1}^{n}[(\pi(x_i) - y_i)\pi(x_i) (1-\pi(x_i))  x_i]\end{aligned}\tag{10}</script><p>其中, $z=w \cdot x$, 则$\pi (x) = \frac{exp(x)}{1+exp(x)}$,其导数为$\pi^{‘} (x)=\pi(x)(1-\pi(x))$</p><p>这里主要考虑的是优化问题,极大似然估计函数是一个凸函数,这是优化问题再最容易优化的模型，我们可以得到全局最优解，而对于$L_2$，由于Sigmoig函数导数的特性，当$\pi (x)$接近0或者1时，此时的倒数就接近0，从而容易使函数陷入局部最优.</p><p>下图是两个损失函数以w为参数的简化图<br><img src="/images/logistic_regression_l2.png" alt="L2"><br><img src="/images/logistic_regression_cross_entropy.png" alt="likelihood"></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/RanMaosong/Machine-Learning-LiHang/blob/master/code/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/plot.ipynb" target="_blank" rel="noopener">绘图源码</a></p><p>逻辑斯蒂回归实现源码: </p><p><a href="https://github.com/RanMaosong/Machine-Learning-LiHang/blob/master/code/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/LogisticRegression.py" target="_blank" rel="noopener">Python</a></p><p><a href="https://github.com/RanMaosong/Machine-Learning-LiHang/blob/master/code/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/LogisticRegression.ipynb" target="_blank" rel="noopener">Jupyter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://ranmaosong.github.io/2019/03/18/ML-ligistic-regression/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://w
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GloVe:Global Vectors for Word Representation</title>
    <link href="http://yoursite.com/2018/11/21/nlp-glove/"/>
    <id>http://yoursite.com/2018/11/21/nlp-glove/</id>
    <published>2018-11-21T14:33:10.000Z</published>
    <updated>2018-11-22T07:14:58.614Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ranmaosong.github.io/2018/11/21/nlp-glove/" target="_blank" rel="noopener">Github</a><br><a href="https://www.jianshu.com/p/a6fb7e3530a0" target="_blank" rel="noopener">简书</a><br><a href="https://blog.csdn.net/u014630987/article/details/84339695" target="_blank" rel="noopener">CSDN</a></p><p>词作为自然语言处理中的一个基本单元，如何表示一个词对于后续的处理任务至关重要，最简单的表示方式是 One-hot，但是该方法表示的词之间是相互独立的，因此局限性很大，需要采用一种更合理的表示方法。</p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>目前，学习词向量的方法主流的有两种：</p><ol><li><p>全局矩阵分解的方法，比如LSA，HAL，这类方法首先统计语料库中的“词-文档”或者“词-词”共现矩阵，然后通过矩阵分解的方法来获得一个低维词向量。“词-文档”矩阵是指矩阵的行表示词，列表示文档，矩阵的元素是改词在文档中出现的次数。“词-词”共现矩阵的行和列都表示一个矩阵，</p></li><li><p>局部上下文窗口的方法， 比如skip-gram，通过神经网络的方法使语料库中给定上下文中共同出现的单词对的概率更大</p></li></ol><p>但是这两种方法都有一个缺点全局矩阵分解的方法虽然利用了全局统计信息，但是他会过度重视共现词频高的单词对，然而这些词并没有多大的语义联系，局部上下文窗口的方法虽然在词类比方面的任务表现的很好，但是没有充分利用全局统计信息。</p><p>该篇文章的主要思想就是两者取其长，结合各自的优点进行词向量学习。</p><h1 id="2-Glove"><a href="#2-Glove" class="headerlink" title="2.Glove"></a>2.Glove</h1><p>首先我们先定义一些符号</p><p>$X$ : 表示“词-词”共现矩阵，是一个对阵矩阵</p><p>$X_{ij}$: 表示词 j 出现在中心词 i 的上下文（基于窗口）的次数。</p><p>$X_i$: 表示任何词出现在词 i 上下文的总的次数。</p><p>$P_{ij}=\frac{X_{ij}}{X_i}$: 表示单词 j 出现在 单词 i 的上下文的概率。</p><p>假设我们有一个检测词 k，则存在如下关系</p><div class="table-container"><table><thead><tr><th>$ratio=\frac{P_{ik}}{P_{jk}}$</th><th style="text-align:right">j,k 相关</th><th style="text-align:center">j,k不相</th></tr></thead><tbody><tr><td>i,k相关</td><td style="text-align:right">1</td><td style="text-align:center">非常大</td></tr><tr><td>i,k不相关</td><td style="text-align:right">非常小</td><td style="text-align:center">1</td></tr></tbody></table></div><p>上面表格的意思就是当词 i，k相关时，如果j，k相关，则$ratio=\frac{P_{ik}}{P_{jk}}$接近于1，如果j，k不想管，此时$P_{jk}$非常小，则$ratio=\frac{P_{ik}}{P_{jk}}$的值会很大，如果i，k不相关，我们可以依次类推出上面的结果。</p><p>如果我们单纯地预测$P_{ij}$，此时就变回skip-gram，我们如何利用全局统计信息呢，此时我们可以利用上面表格思想，我们预测概率的比率，即：</p><script type="math/tex; mode=display">F(w_i, w_j, \hat w_k)=\frac{P_{ik}}{P_{ij}} \tag{1}</script><p>其中，$w$表示一个d维的词向量，$\hat w$ 表示上下文检测词。这里的F存在很多解，但是我们可以一步步地添加约束来得到最后的一个解</p><p>因为向量空间具有线性结构，因此我们只考虑函数 $F$ 在目标词的差异上进行运算（这个原因个人觉得理由有点牵强）</p><script type="math/tex; mode=display">F(w_i-w_j, \hat w_k)=\frac{P_{ik}}{P_{ij}} \tag{2}</script><p><strong>这句话是个人的理解</strong>：个人感觉这一部还有个原因是为了减少计算量。</p><p>从上面公式我们可以看到公式左边是个向量，右边是一个标量，因此我们可以使用向量的点乘来解决这个问题。</p><script type="math/tex; mode=display">F((w_i-w_j)^T\hat w_k)=\frac{P_{ik}}{P_{ij}}  \tag{3}</script><p>即</p><script type="math/tex; mode=display">F(w_i^T\hat w_k-w_j^T\hat w_k)=\frac{P_{ik}}{P_{ij}}  \tag{4}</script><p>在这里我们需要寻找一个在 + 和 × 之间的同态函数，比如：</p><script type="math/tex; mode=display">F(w_i^T\hat w_k-w_j^T\hat w_k)=\frac{F(w_i^T\hat w_k)}{F(w_j^T\hat w_k)} \tag{5}</script><p>该式在结合上面地公式(4)：即</p><script type="math/tex; mode=display">\frac{F(w_i^T\hat w_k)}{F(w_i^T\hat w_k)}=\frac{P_{ik}}{P_{ij}} \tag{6}</script><p>因此：</p><script type="math/tex; mode=display">F(w_i^T\hat w_k)=P_{ik}=\frac{X_{ik}}{X_i} \tag{7}</script><p>对于满足公式(5)的函数，我们可以想到有指数函数 exp，即：</p><script type="math/tex; mode=display">\exp(w_i^T\hat w_k-w_j^T\hat w_k)=\frac{\exp(w_i^T\hat w_k)}{\exp(w_j^T\hat w_k)} \tag{8}</script><p>结合公式(7)和(8)我们可以得到</p><script type="math/tex; mode=display">exp(w_i^T\hat w_k)=P_{ik}=\frac{X_{ik}}{X_i} \tag{9}</script><p>我们对其取对数可以得到：</p><script type="math/tex; mode=display">w_i^T\hat w_k=\log(P_{ik})=\log(X_{ik}) - \log(X_i) \tag{10}</script><p>由于上面左边具有交换性，而右边不具有，同时$X_i$和k无关因此可以作为一个偏织项，因此公式(10)可以演变为</p><script type="math/tex; mode=display">w_i^T\hat w_k + b_i + \hat b_k=log(X_{ik}) \tag{11}</script><p>其中$\hat b_k$ 作为 k 的偏置项来保持公式的对称性。</p><p>同事为了防止$X_{ik}$接近0时，log 趋向于负无穷大，因此我们对右式加上一个平滑项，即$\log(X_{ik}) \to log(1+X_{ik})$</p><p>因此该模型的损失函数为：</p><script type="math/tex; mode=display">J = \sum _{i,j}^{V} (w_i^T\hat w_k + b_i + \hat b_k-log(X_{ik}) )^2 \tag{12}</script><p>在这里有个问题就是他对每个单词对平等对待，但是这是不合理的，应该对 $X_{ij}$值较大的，权重应该更大，同时，我们又不应该过度重视高频词，该论文选取的权重函数如下：</p><script type="math/tex; mode=display">f(x)=\begin{cases}-(x/x_{max})^\alpha,\quad if x<x_{max} \\1, otherwise\end{cases}\tag{13}</script><p>最终该损失函数如下：</p><script type="math/tex; mode=display">J = \sum _{i,j}^{V} f(X_{ij})(w_i^T\hat w_k + b_i + \hat b_k-log(X_{ik}) )^2 \tag{14}</script><p>论文中$\alpha$ 和 $x_{max}$分别取值$3/4$ 和 100.</p><h1 id="3-和Skip-gram的联系"><a href="#3-和Skip-gram的联系" class="headerlink" title="3. 和Skip-gram的联系"></a>3. 和Skip-gram的联系</h1><p>前面提过，Glove 结合了之前两种方法的优点，但是他是如何结合或者如何从Skip-gram演变而来的呢？</p><p>总所周知，Skip-gram模型可以通过如下一个公式来表达，即Softmax：</p><script type="math/tex; mode=display">Q_{ij}=\frac{exp(w_i^T\hat w_j)}{\sum_{k=1}^V exp(w_i^T\hat w_k)} \tag{15}</script><p>则该模型的损失函数为：</p><script type="math/tex; mode=display">J =-\sum_{i \in corpus, j \in context(i)} \log Q_{ij} \tag{16}</script><p>由于我们需要利用全局统计信息，因此一个单词对可能出现很多次，因此，我们首先把所有相同的单词对先进行计算，即</p><script type="math/tex; mode=display">\begin{align}J &= -\sum_{i=1}^V\sum_{j=1}^V X_{ij} \log Q_{ij}\\&=-\sum_{i=1}^V X_i \sum_{j=1}^V P_{ij} \log Q_{ij}\\&=\sum_{i=1}^V X_iH(P_i, Q_i)\end{align}\tag {17}</script><p>由于交叉熵具有某些缺点，交叉熵具有长尾效应，当过分重视不太可能的事件时建模效果不是很好，而且交叉熵需要Q归一化，这样计算很大，因此使用这样一个未归一化的最小二成损失来替代 </p><script type="math/tex; mode=display">\hat J = \sum_{i,j} X_i (X_{ij} - \exp(w_i^T \hat w _j))^2\tag{18}</script><p>这里是因为18式中当$X_{ij}$变得很大时，训练变得复杂，于是使用对数可以缓解或补交这个问题,即：</p><script type="math/tex; mode=display">\hat J = \sum_{i,j} X_i (w_i^T \hat w _j- \log X_{ij} )^2\tag{19}</script><p>这里$X_i$可以视为一个权重项，我们通过调整这个权重和添加权重项公式19就演变为公式14.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://ranmaosong.github.io/2018/11/21/nlp-glove/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.co
      
    
    </summary>
    
      <category term="NLP(自然语言处理)" scheme="http://yoursite.com/categories/NLP-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="NLP(自然语言处理)" scheme="http://yoursite.com/tags/NLP-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>util.md</title>
    <link href="http://yoursite.com/2018/11/05/util-md/"/>
    <id>http://yoursite.com/2018/11/05/util-md/</id>
    <published>2018-11-05T12:43:15.000Z</published>
    <updated>2018-11-05T12:47:06.151Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些常用的工具包教程链接：</p><ol><li>[Visdom]:      <a href="https://zhuanlan.zhihu.com/p/32025746(知乎" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32025746(知乎</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;收集一些常用的工具包教程链接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[Visdom]:      &lt;a href=&quot;https://zhuanlan.zhihu.com/p/32025746(知乎&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhu
      
    
    </summary>
    
      <category term="Util" scheme="http://yoursite.com/categories/Util/"/>
    
    
      <category term="Util" scheme="http://yoursite.com/tags/Util/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 172.FactorialTrailingZeroes(阶乘后的零)</title>
    <link href="http://yoursite.com/2018/10/07/LeetCode-172-FactorialTrailingZeroes/"/>
    <id>http://yoursite.com/2018/10/07/LeetCode-172-FactorialTrailingZeroes/</id>
    <published>2018-10-07T09:14:00.000Z</published>
    <updated>2018-10-07T11:00:04.527Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ranmaosong.github.io/2018/10/07/LeetCode-172-FactorialTrailingZeroes/" target="_blank" rel="noopener">GitHub链接</a><br><a href="https://www.jianshu.com/p/2d441cf3f049" target="_blank" rel="noopener">简书链接</a><br><a href="https://blog.csdn.net/u014630987/article/details/82960232" target="_blank" rel="noopener">CSDN链接</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数 n， 返回 $n!$ 结果尾数中零的个数。<br><strong>示例1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 0</span><br><span class="line">解释: 3! = 6, 尾数中没有零。</span><br></pre></td></tr></table></figure></p><p><strong>示例2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! = 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure></p><p><strong>说明:</strong> 算法的时间复杂度应为 $O(log n)$</p><h1 id="方法一（错误的）"><a href="#方法一（错误的）" class="headerlink" title="方法一（错误的）"></a>方法一（错误的）</h1><p>求出 $n!$ 的值或者在求的过程中，遇到末尾有0，先除以10来减小数，虽然该算法原理上可以行，但是有两个问题，一、时间复杂度为 $O(n)$，二、结果不对，出现这个问题的原因是编程语言每种类型有自己的数组范围，因此会溢出。所以该方法实际不可行</p><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>考虑一个问题，位数为零是由2*5产生的，而吧每个数分解，出现5的次数必出现2的次数要少很多，因此，我们通过统计有多少个 5 即可判断尾数有多少个 0.先上代码在将原理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_172</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count += n / <span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LeetCode_172 leetCode = <span class="keyword">new</span> LeetCode_172();</span><br><span class="line">        System.out.println(leetCode.trailingZeroes(<span class="number">3</span>));</span><br><span class="line">        System.out.println(leetCode.trailingZeroes(<span class="number">5</span>));</span><br><span class="line">        System.out.println(leetCode.trailingZeroes(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先我们先统计n 包含一个5的个数，然后统计包含两个5的个数，依次类推。比如：35！，包含一个5的个数为5,10， 15， 20， 25， 30， 35，即35/5 = 7个，然而当我们遇到25的元素时，里面包含两个5，所以通过 $n/5^2$ ，更大的数一次类推，当 $5^k &gt; n$时即停止，在上面代码中表现为n&gt;0；</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://github.com/RanMaosong/RanMaosong.github.io" target="_blank" rel="noopener">感谢大家的阅读和支持, 欢迎大家上星.</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://ranmaosong.github.io/2018/10/07/LeetCode-172-FactorialTrailingZeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub链接&lt;/a&gt;&lt;br&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>169. Majority Element(求众数)</title>
    <link href="http://yoursite.com/2018/10/06/LeetCode-169-MajorityElement/"/>
    <id>http://yoursite.com/2018/10/06/LeetCode-169-MajorityElement/</id>
    <published>2018-10-06T14:03:52.000Z</published>
    <updated>2018-10-07T08:11:02.871Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ranmaosong.github.io/2018/10/06/LeetCode-136-SingleNumber/" target="_blank" rel="noopener">GIthub</a><br><a href="https://www.jianshu.com/p/cf75842c46c0" target="_blank" rel="noopener">简书</a><br><a href="https://blog.csdn.net/u014630987/article/details/82958884" target="_blank" rel="noopener">CSDN</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在众数。<br><strong>示例1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p><strong>示例2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><h1 id="方法一-暴力破解"><a href="#方法一-暴力破解" class="headerlink" title="方法一: 暴力破解"></a>方法一: 暴力破解</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>最简单最直接的方法是统计每个数出现的次数，如果它出现的次数 大于 $\lfloor n/2 \rfloor$, 则这个数就为这个数组的众数。因此实现此算法，需要两个嵌套的 for 循环，外层循环遍历数组来确定当前值，内层循环同样遍历数组，它则用来统计当前值出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_169</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * O(n^2)</span></span><br><span class="line"><span class="comment">         *  Time Limit Exceeded</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[j])</span><br><span class="line">                    ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, count);</span><br><span class="line">            <span class="keyword">if</span> (max &gt; nums.length / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度： $O(n^2)$</p><p>由于该方法包含两个嵌套的 for 循环，每个循环迭代n次，因此该算法的时间复杂度为 $O(n^2)$</p></li><li><p>空间复杂度： $O(1)$</p></li></ul><h1 id="方法二：-HashMap"><a href="#方法二：-HashMap" class="headerlink" title="方法二： HashMap"></a>方法二： HashMap</h1><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>在统计元素出现次数的时候， 我们可以使用一个 HashMap 来保存当前已出现的元素出现的次数，这样可以避免重复的统计，从而在一个 for 循环里完成任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maosong Ran</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/10/06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> maosongran@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_169</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * O(n) O(n)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            Integer num = count.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="keyword">null</span>)</span><br><span class="line">                num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++num;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (num &gt; nums.length / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            count.put(nums[i], num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度： $O(n)$</p><p>由于我们只需要遍历一次数组，即可完成统计任务，因此，时间复杂度为$O(n)$</p></li><li><p>空间复杂度： $O(n)$<br>由于数组总存在众数，而众数的条件是其出现次数大于 $\lfloor n/2 \rfloor$,因此最坏情况，HashMap包含 $n - (\lfloor n/2 \rfloor + 1)$个元素，最好情况包含 1 个元素，因此空间复杂度为O(n)</p></li></ul><h1 id="方法三：-排序"><a href="#方法三：-排序" class="headerlink" title="方法三： 排序"></a>方法三： 排序</h1><p>由于众数的是其出现次数大于 $\lfloor n/2 \rfloor$ 的值，因此无论该值的大小是多少，该值总会出现在中心位置：对于数组长度为偶数时，为最中间两个数，为基数时，为最中间一个数。<br>！<a href="/images/leetcode169.png">Sorting</a></p><p>上图中，数组下面的线表示当众数出现在排序数组的最左侧，数组上面的线表示当总数出现在排序数组的最右侧时，测试是众数出现的两个极端情况，其余情况在这两种情况之间，因此总数总是出现在排序数组的最中心位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_169</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度： $O(nlog n)$</p><p>在Java和Python中，数组排序的时间复杂度为$O(nlog n)$</p></li><li><p>空间复杂度： $O(n)$ 或 $O(1)$</p><p>如果允许在原地进行排序时，我们不需要额外的空间，因此，空间复杂度为$O(1)$,如果不允许，则需要额外的等大的数组来存放该有序数组，因此空间复杂度为 $O(n)$</p></li></ul><h1 id="方法三：-分治法"><a href="#方法三：-分治法" class="headerlink" title="方法三： 分治法"></a>方法三： 分治法</h1><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><p>分治法是算法中经常遇到的一种求解问题的方法，它将大问题小化，复杂问题简单化，因此可以很容易得出问题的解。</p><p>在本题中，我们将数组递归地从中间将大数组分成左右两个小数组，然后求左右两个小数组的的众数，如果这两个众数相等，则这个数也是大数组的众数，如果两个数不相等，则这二者之一必有一个是大数组的众数，为什么呢？</p><p>若假设这两个数之一不是大数组的众数，由于他们是小数组的众数，因此，他们出现次数各占小数组的一半以上，因此这两个数在大数组中的出现次数必大于 $\lfloor n/2 \rfloor$,因此剩下位置的值即便是相同，他们出现的次数也不大于 $\lfloor n/2 \rfloor$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_169</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> divideAndConquer(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">divideAndConquer</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right)</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> leftMajority = divideAndConquer(nums, left, mid);</span><br><span class="line">            <span class="keyword">int</span> rightMajority = divideAndConquer(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="comment">//            System.out.println(leftMajority + "-&gt;" + rightMajority);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftMajority == rightMajority)</span><br><span class="line">                <span class="keyword">return</span> leftMajority;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> leftCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rightCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i &lt;= right; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == leftMajority)</span><br><span class="line">                    ++leftCount;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == rightMajority) &#123;</span><br><span class="line">                    ++rightCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(leftMajority + ":" + leftCount + ", " + rightMajority + ": " + rightCount);</span></span><br><span class="line">            <span class="keyword">return</span> leftCount &gt; rightCount ? leftMajority : rightMajority;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度： $O(nlog n)$</p></li><li><p>空间复杂度： $O(ll0g n)$</p></li></ul><h1 id="方法五：-摩尔投票法"><a href="#方法五：-摩尔投票法" class="headerlink" title="方法五： 摩尔投票法"></a>方法五： 摩尔投票法</h1><h2 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h2><p>大致思路，首先有一个统计当前投票数的变量 count， 当 count == 0 时，我们以当前变量作为候选众数，然后从当前变量位置开始，若值等于候选众数的值，则count加1，若不相等，则减一，依次遍历玩数组，当遍历完数组，若 count == 0，则该数组不存在众数，不等于0时，此时的候选众数即位真正的众数。</p><p>原理： 由于众数票数大于 $\lfloor n/2 \rfloor$,因此即便它的票数减去其他所有的票数，它的票数也大于零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_169</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  count = <span class="number">0</span>;</span><br><span class="line">        Integer candiate = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candiate = num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            count += (candiate == num) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candiate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度： $O(n)$</p></li><li><p>空间复杂度： $O(1)$</p></li></ul><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://github.com/RanMaosong/RanMaosong.github.io" target="_blank" rel="noopener">感谢大家的阅读和支持, 欢迎大家上星.</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://ranmaosong.github.io/2018/10/06/LeetCode-136-SingleNumber/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GIthub&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="Weekly Algorithm" scheme="http://yoursite.com/categories/Weekly-Algorithm/"/>
    
    
      <category term="Weekly Algorithm" scheme="http://yoursite.com/tags/Weekly-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 136.Single Number(只出现一次的数字)</title>
    <link href="http://yoursite.com/2018/10/06/LeetCode-136-SingleNumber/"/>
    <id>http://yoursite.com/2018/10/06/LeetCode-136-SingleNumber/</id>
    <published>2018-10-06T05:49:39.000Z</published>
    <updated>2018-10-07T09:14:11.348Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ranmaosong.github.io/2018/10/06/LeetCode-136-SingleNumber/" target="_blank" rel="noopener">GitHub</a><br><a href="https://www.jianshu.com/p/df7d256e2bea" target="_blank" rel="noopener">简书</a><br><a href="https://blog.csdn.net/u014630987/article/details/82951316" target="_blank" rel="noopener">CSDN</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明</strong><br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p><strong>示例2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p><strong>难度系数:</strong> 简单</p><h1 id="解题思路一"><a href="#解题思路一" class="headerlink" title="解题思路一"></a>解题思路一</h1><p>常规方法是,遍历数组,然后统计每个值出现的次数,最后在选择出现次数为1的那个值.该算法的时间复杂度为O(N),首先是统计数组,此时要遍历整个数组,然后是要遍历我们的统计数组,此时有事一个O(N),由于我们使用了一个统计数组来保存每个值出现的次数,此时需要的空间复杂度为O(n),因此不符合要求.</p><h1 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h1><p>为了解决不需要额外的空间这个要求,我们可以使用位操作中的异或规则来进行处理.异或运算法则如下</p><ol><li>a $\oplus$ a = 0, a $\oplus$ 0=a</li><li>a $\oplus$ b = b $\oplus$ a</li><li>a $\oplus$ b $\oplus$ c = a $\oplus$ (b $\oplus$ c) = a $\oplus$ (c $\oplus$ b) = (a $\oplus$ b) $\oplus$ c</li></ol><p>其中,第一条规则说明,当某个数出现两次时,通过 $\oplus$ 变为0,出现一次时依然保持原来的数,第二、三条的交换律和分配律说明通过多次 $\oplus$ 操作最终解决本题。</p><p><strong>注意</strong>: 本体题目中指出除了某个元素值出现一次外其余的均出现两次，根据法则一可以看出本算法只适合除了某个元素出现一次外，其余元素出现偶数次的情况。</p><p>比如在示例二中的 $\oplus$ 操作：</p><script type="math/tex; mode=display">\begin{aligned}    4 \oplus 1 \oplus 2 \oplus 1 \oplus 2 &=  4 \oplus 1 \oplus 1 \oplus 2 \oplus 2 \\    &= 4 \oplus (1 \oplus 1) \oplus (2 \oplus 2)\\    &=4\end{aligned}</script><h1 id="Java实现代码"><a href="#Java实现代码" class="headerlink" title="Java实现代码"></a>Java实现代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maosong Ran</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/10/06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> maosongran@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_136</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            result ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LeetCode_136 leetCode = <span class="keyword">new</span> LeetCode_136();</span><br><span class="line">        System.out.println(leetCode.singleNumber(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;));</span><br><span class="line">        System.out.println(leetCode.singleNumber(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://github.com/RanMaosong/RanMaosong.github.io" target="_blank" rel="noopener">感谢大家的阅读和支持, 欢迎大家上星.</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://ranmaosong.github.io/2018/10/06/LeetCode-136-SingleNumber/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="Weekly Algorithm" scheme="http://yoursite.com/categories/Weekly-Algorithm/"/>
    
    
      <category term="Weekly Algorithm" scheme="http://yoursite.com/tags/Weekly-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第二次作业</title>
    <link href="http://yoursite.com/2018/09/17/ta-work-02/"/>
    <id>http://yoursite.com/2018/09/17/ta-work-02/</id>
    <published>2018-09-17T13:09:48.000Z</published>
    <updated>2018-09-22T04:25:57.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现在单向链表中-返回某个节点的前驱"><a href="#实现在单向链表中-返回某个节点的前驱" class="headerlink" title="实现在单向链表中,返回某个节点的前驱."></a>实现在单向链表中,返回某个节点的前驱.</h1><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>单向链表的特点是链表只有一个方向,即只有从前驱结点指向后继结点的指针,而没有后继节点指向前驱结点的指针,结构图大致如下:<br><img src="https://upload-images.jianshu.io/upload_images/5208761-03db3a5a57fd70ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linklist1.png"><br>从图可以看出,如果我们要访问第三个结点,我们只能从头指针依次便利每个后继结点,直至访问到第三个结点,因此在单向链表中,我们查找某个元素的时间复杂度 $O(n)$.</p><p>基于链表的单向特点,因此我们必须从头开始遍历才能找到某个节点的前驱.以上图为例进行讲解,假如我们要寻找第三个结点的前驱,我们如何实现呢?</p><ol><li>首先我们需要申明两个临时变量pre 和 cur,分别指向Head 头结点和Head-&gt;next(为null或为第一个结点),这样pre和cur就构成一个相关的对,pre表示cur的前驱,当cur到达第三个结点时,此时pre就是我们要找的前驱.<br><img src="https://upload-images.jianshu.io/upload_images/5208761-bb412a44ed651d75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linklist2.png"></li><li>再循环中,我们依次把pre和cur向前同时推进,直至cur到达事先定义的结点.<ul><li>在上图中,cur=1,不是我们要找的结点3,因此pre和cur向前移动,即pre=cur, cur=next;<br><img src="https://upload-images.jianshu.io/upload_images/5208761-ba2086541433a47a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linklist3.png"></li></ul></li></ol><ul><li>此时,cur=2,不符合我们的条件,我们继续执行上面的操作;<br><img src="https://upload-images.jianshu.io/upload_images/5208761-54cc3f96b5132267.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linklist4.png"><br>现在cur=3,满足我们的条件,此时pre就是他的前驱,返回该节点即可.<h2 id="下面是实现代码-仅供参考"><a href="#下面是实现代码-仅供参考" class="headerlink" title="下面是实现代码,仅供参考"></a>下面是实现代码,仅供参考</h2><h3 id="c语言"><a href="#c语言" class="headerlink" title="　c语言"></a>　<strong>c语言</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *Linklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链表</span></span><br><span class="line"><span class="function">Linklist <span class="title">createList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表长度:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">    Linklist head = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Linklist tail = head;</span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第%d个节点内容:"</span>, (i+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val);</span><br><span class="line">        Linklist node = (Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = val;</span><br><span class="line">        node-&gt;next = tail-&gt;next;</span><br><span class="line">        tail-&gt;next = node;</span><br><span class="line">        tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找给定节点的前驱</span></span><br><span class="line"><span class="function">Node* <span class="title">preNodeOf</span><span class="params">(Linklist <span class="built_in">list</span>, Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* cur = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    Node* pre = <span class="built_in">list</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;data != node-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引查找指定节点,index 从1开始</span></span><br><span class="line"><span class="function">Node* <span class="title">getNode</span><span class="params">(Linklist <span class="built_in">list</span>, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* node = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示链表内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showLinklist</span><span class="params">(Linklist <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* node = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(Linklist <span class="built_in">list</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Node* node = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++len;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist <span class="built_in">list</span> = createList();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表内容:"</span>);</span><br><span class="line">    showLinklist(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = length(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n输入需要查找前驱的节点的索引(0&lt; n &lt;=%d):"</span>, len);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;index);</span><br><span class="line">    Node* node = getNode(<span class="built_in">list</span>, index);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"第%d个节点的内容:%d\n"</span>, index, node-&gt;data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    node = preNodeOf(<span class="built_in">list</span>, node);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, node-&gt;data);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该节点为第一个节点,无前驱节点!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="C-代码-这里使用了模板类"><a href="#C-代码-这里使用了模板类" class="headerlink" title="　C++代码:这里使用了模板类"></a>　<strong>C++代码</strong>:这里使用了模板类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点类, 使用了模板类,方便数据类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt;* next;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(T v, Node&lt;T&gt;* node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* head;</span><br><span class="line">    Node&lt;T&gt;* tail;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkList();</span><br><span class="line">    ~LinkList();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    Node&lt;T&gt;* getNode(<span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(T data)</span></span>;</span><br><span class="line">    Node&lt;T&gt;* preNodeOf(Node&lt;T&gt;*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkList</span>&lt;T&gt;:</span>:LinkList(): count(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail = head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入链表初始长度:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        T data;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">"个节点的内容:"</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line">        append(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkList</span>&lt;T&gt;:</span>:~LinkList()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* node = head-&gt;next;</span><br><span class="line">    Node&lt;T&gt;* tmp;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">LinkList</span>&lt;T&gt;:</span>:size()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Node</span>&lt;T&gt;* <span class="title">LinkList</span>&lt;T&gt;:</span>:getNode(<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; count || index &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Index Error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* node = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index &amp;&amp; node-&gt;next; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt;:</span>:print()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* node = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node-&gt;data &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt;:</span>:append(T data)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = node;</span><br><span class="line">    tail = node;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Node</span>&lt;T&gt;* <span class="title">LinkList</span>&lt;T&gt;:</span>:preNodeOf(Node&lt;T&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* pre = head;</span><br><span class="line">    Node&lt;T&gt;* cur = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;data != node-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre == head) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span> = LinkList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"链表内容:"</span>;</span><br><span class="line">    <span class="built_in">list</span>.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">list</span>.size();</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入需要查找前驱的节点的索引(1 &lt;= n &lt;="</span> &lt;&lt; size &lt;&lt; <span class="string">"):"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt;* node = <span class="built_in">list</span>.getNode(index);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; index &lt;&lt; <span class="string">"个节点的内容:"</span> &lt;&lt; node-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt;* pre = <span class="built_in">list</span>.preNodeOf(node);</span><br><span class="line">    <span class="keyword">if</span> (pre)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; index &lt;&lt; <span class="string">"个节点的前驱:"</span> &lt;&lt; pre-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"该节点为第一个节点,无前驱"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码仅供学习使用,课程要求为C/C++变成语言.</p><h3 id="Python3"><a href="#Python3" class="headerlink" title="　Python3"></a>　<strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = Node(<span class="number">0</span>)</span><br><span class="line">        self._tail = self._head</span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        node = Node(data, <span class="keyword">None</span>)</span><br><span class="line">        self._tail.next = node</span><br><span class="line">        self._tail = node</span><br><span class="line">        self._count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        node = self._head.next</span><br><span class="line">        <span class="keyword">while</span> (node):</span><br><span class="line">            print(node.data, end=<span class="string">"  "</span>)</span><br><span class="line">            node = node.next</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_n_elems</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            data = int(input(<span class="string">"请输入第%d个节点的内容:"</span> % (i+<span class="number">1</span>)))</span><br><span class="line">            self.append(data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_node_of</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        pre = self._head</span><br><span class="line">        cur = pre.next</span><br><span class="line">        <span class="keyword">while</span>(cur.data != node.data):</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pre == self._head):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_node</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">1</span> &lt;= index &lt;= self.size() ):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Index Error!"</span>)</span><br><span class="line">        node = self._head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(index):</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    linklist = LinkList()</span><br><span class="line">    length = int(input(<span class="string">"请输入链表长度:"</span>))</span><br><span class="line">    linklist.add_n_elems(length)</span><br><span class="line">    print(<span class="string">"链表内容:"</span>, end=<span class="string">""</span>)</span><br><span class="line">    linklist.show()</span><br><span class="line"></span><br><span class="line">    index = int(input(<span class="string">"\n输入需要查找前驱的节点的索引(0&lt; n &lt;=%d):"</span> % linklist.size()))</span><br><span class="line">    node = linklist.get_node(index)</span><br><span class="line">    pre_node = linklist.pre_node_of(node)</span><br><span class="line">    print(<span class="string">"第%d个节点的内容:%d"</span> % (index, node.data))</span><br><span class="line">    <span class="keyword">if</span> pre_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        print(<span class="string">"第%d个节点的前驱的内容内容:%d"</span> % (index, pre_node.data))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"该节点无前驱节点"</span>)</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="　Java"></a>　<strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linklist</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Linklist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        tail = head;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(T data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = <span class="keyword">new</span> Node(data);</span><br><span class="line">        tail.next = node;</span><br><span class="line">        tail = node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> index)</span>  <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; count)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Index Error!"</span>);</span><br><span class="line">        Node&lt;T&gt; node = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; ++i) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">preNodeOf</span><span class="params">(Node&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; pre = head;</span><br><span class="line">        Node&lt;T&gt; cur = pre.next;</span><br><span class="line">        <span class="keyword">while</span> (cur.data != node.data) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre == head)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = head.next;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.data + <span class="string">"  "</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        Linklist&lt;Integer&gt; list = <span class="keyword">new</span> Linklist&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        System.out.print(<span class="string">"请输入链表长度:"</span>);</span><br><span class="line">        length = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i) &#123;</span><br><span class="line">            System.out.print(<span class="string">"请输入第"</span> + (i+<span class="number">1</span>) + <span class="string">"个节点的内容:"</span>);</span><br><span class="line">            <span class="keyword">int</span> data = scan.nextInt();</span><br><span class="line">            list.append(data);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"链表内容:"</span>);</span><br><span class="line">        list.show();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"\n输入需要查找前驱的节点的索引(1&lt;= n &lt;="</span> + list.size() + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">int</span> index = scan.nextInt();</span><br><span class="line">        Node&lt;Integer&gt; node;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            node = list.getNode(index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// e.printStack();</span></span><br><span class="line">            node = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        Node&lt;Integer&gt; pre_node = list.preNodeOf(node);</span><br><span class="line">        System.out.println(<span class="string">"第"</span> + index + <span class="string">"个节点的内容:"</span> + node.data);</span><br><span class="line">        <span class="keyword">if</span> (pre_node != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"第"</span> + index + <span class="string">"个节点的前驱的内容内容:"</span>  + pre_node.data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"该节点无前驱节点"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实现在单向链表中-返回某个节点的前驱&quot;&gt;&lt;a href=&quot;#实现在单向链表中-返回某个节点的前驱&quot; class=&quot;headerlink&quot; title=&quot;实现在单向链表中,返回某个节点的前驱.&quot;&gt;&lt;/a&gt;实现在单向链表中,返回某个节点的前驱.&lt;/h1&gt;&lt;h2 id=
      
    
    </summary>
    
      <category term="Teaching Assistant" scheme="http://yoursite.com/categories/Teaching-Assistant/"/>
    
    
      <category term="Teaching Assistant" scheme="http://yoursite.com/tags/Teaching-Assistant/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第一次作业</title>
    <link href="http://yoursite.com/2018/09/17/ta-work-01/"/>
    <id>http://yoursite.com/2018/09/17/ta-work-01/</id>
    <published>2018-09-17T13:09:42.000Z</published>
    <updated>2018-09-22T04:25:47.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-逻辑结构和物理结构有什么不同"><a href="#1-逻辑结构和物理结构有什么不同" class="headerlink" title="1.    逻辑结构和物理结构有什么不同?"></a>1.    逻辑结构和物理结构有什么不同?</h1><p>逻辑结构是指从操作对象抽象出的数学模型，其结构定义中的关系用于描述数据元素之间的逻辑关系。<br>逻辑结构在计算机中的表示称为物理结构或存储结构，根据数据元素在计算机中的表示方法，可分为顺序存储结构与链式存储结构。</p><h1 id="2-算法和程序有什么不同？"><a href="#2-算法和程序有什么不同？" class="headerlink" title="2.    算法和程序有什么不同？"></a>2.    算法和程序有什么不同？</h1><p>算法是指解决问题的一种方法或一个过程。<br>算法是若干指令的有穷序列，满足<strong>性质</strong>：</p><blockquote><p>(1)输入：由外部提供的量作为算法的输入.<br>(2)输出：算法产生至少一个量作为输出.<br>(3)确定性：算法的每一步骤必须有确切的定义.<br>(4)有限性：算法的有穷性是指算法必须能在执行有限个步骤之后终止.<br>(5) 可行性，算法需要考虑设计的可能，程序则具体是实现算法上的设计</p></blockquote><p>程序是算法在计算机上用某种程序设计语言的具体实现。<br>程序可以不满足算法的性质(4)。<br>例如操作系统，是一个在无限循环中执行的程序，因而不是一个算法。<br>操作系统的各种任务可看成是单独的问题，每一个问题由操作系统中的一个子程序通过特定的算法来实现。该子程序得到输出结果后便终止。</p><h1 id="3-什么是ADT？"><a href="#3-什么是ADT？" class="headerlink" title="3.    什么是ADT？"></a>3.    什么是ADT？</h1><p>抽象数据类型（ADT）是一个实现包括储存数据元素的存储结构以及实现基本操作的算法，是数据结构作为一个软件组件的实现。ADT的接口用一种类型上的一组操作来定义，每一个操作由它的输入和输出定义。ADT并不会指定数据类型如何实现，这些实现细节对于ADT的用户是隐藏的，并且通过封装来阻止外部对它的访问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-逻辑结构和物理结构有什么不同&quot;&gt;&lt;a href=&quot;#1-逻辑结构和物理结构有什么不同&quot; class=&quot;headerlink&quot; title=&quot;1.    逻辑结构和物理结构有什么不同?&quot;&gt;&lt;/a&gt;1.    逻辑结构和物理结构有什么不同?&lt;/h1&gt;&lt;p&gt;逻辑结构
      
    
    </summary>
    
      <category term="Teaching Assistant" scheme="http://yoursite.com/categories/Teaching-Assistant/"/>
    
    
      <category term="Teaching Assistant" scheme="http://yoursite.com/tags/Teaching-Assistant/"/>
    
  </entry>
  
  <entry>
    <title>多元线性回归——Day3</title>
    <link href="http://yoursite.com/2018/09/13/ML-100-Days-003/"/>
    <id>http://yoursite.com/2018/09/13/ML-100-Days-003/</id>
    <published>2018-09-13T13:43:18.000Z</published>
    <updated>2018-09-13T14:40:14.231Z</updated>
    
    <content type="html"><![CDATA[<p><strong>相关链接:</strong><br><a href="https://ranmaosong.github.io/2018/09/13/ML-100-Days-003/" target="_blank" rel="noopener">Github地址</a><br><a href="https://www.jianshu.com/p/56b31d24823c" target="_blank" rel="noopener">简书地址</a><br><a href="https://blog.csdn.net/u014630987/article/details/82695498" target="_blank" rel="noopener">CSDN地址</a></p><hr><p>上一节我们讲解了简单现行回归,该回归的输入特征只有 1 个.本节我们对多元线性回归进行讲解,其输入具有多个特征.多元线性回归通过对训练数据拟合一个多元线性方程来对2或多个特征和一个响应值之间进行建模.多元线性回归的处理步骤和上一节的简单线性回归类似,只是在评估阶段存在差异.你可以通过多元线性回归来发现那个因素或特征对预测结果具有较大的影响和找到不同特征是如何相互影响的.多元线性回归数学表达如下:</p><script type="math/tex; mode=display">y = b_0 + b_1x_1 + b_2x_2 ...... + b_nx_n</script><p>从公式我们可以发现, 当n=1时,多元线性回归就变成简单线性回归,因此,简单线性回归是多元线性回归的一个特例.</p><h1 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h1><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>在我们进行线性回归建模时,</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1. 数据预处理"></a>1. 数据预处理</h2><h2 id="2-训练模型"><a href="#2-训练模型" class="headerlink" title="2. 训练模型"></a>2. 训练模型</h2><h2 id="3-预测测试集"><a href="#3-预测测试集" class="headerlink" title="3. 预测测试集"></a>3. 预测测试集</h2><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://github.com/RanMaosong/RanMaosong.github.io" target="_blank" rel="noopener">感谢大家的阅读和支持, 欢迎大家上星.</a>.该博客的原始Github项目地址<a href="https://github.com/Avik-Jain/100-Days-Of-ML-Code/blob/master/Code/Day3_Multiple_Linear_Regression.md" target="_blank" rel="noopener">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;相关链接:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://ranmaosong.github.io/2018/09/13/ML-100-Days-003/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github地址&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习100天" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"/>
    
    
      <category term="机器学习100天" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>简单线性回归——Day2</title>
    <link href="http://yoursite.com/2018/09/13/ML-100-Days-002/"/>
    <id>http://yoursite.com/2018/09/13/ML-100-Days-002/</id>
    <published>2018-09-13T06:22:04.000Z</published>
    <updated>2018-09-13T13:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>相关链接:</strong><br><a href="https://ranmaosong.github.io/2018/09/13/ML-100-Days-002/" target="_blank" rel="noopener">Github地址</a><br><a href="https://www.jianshu.com/p/ff991ff8d4c7" target="_blank" rel="noopener">简书地址</a><br><a href="https://blog.csdn.net/u014630987/article/details/82687507" target="_blank" rel="noopener">CSDN地址</a></p><hr><p>在预测问题中,我们会经常遇到两种常用术语:回归(Regression)和分类(classification),他们的区别是回归算法解决的是预测连续值,而分类问题则是预测的是离散值,因此回归模型的输出是无限的,而分类问题的输出是有限的.</p><p>在统计学中，线性回归是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。</p><p>本文首先介绍简单线性回归，下一节介绍多元线性回归。简单线性回归就是根据一个特征 <code>X</code> 来预测一个与其相关的变量 <code>Y</code>。通常我们我们假设这两种变量之间是现行相关的,即可以通过一条直线把这些变量区分开.因此,简单线性回归就是我们试图寻找一个线性函数,该函数以特征 <code>X</code> 为输入,输出一个变量,且在训练集中,使其预测的值尽可能接近目标值.</p><p>在本文我们以一个学生学习时间(hours),来预测的他该门课程的分数(scores).我们假设这两个变量之间存在某种线性关系,如图所示<br><img src="/images/simple_linear_regression.png" alt="simple_linear_regression"></p><p>我们的目标是找到最有的 $b_0$ 和 $b_1$,使我们训练集中的数据,我们的预测值和真实值之间的误差最小.即</p><script type="math/tex; mode=display">b_0^*,b_1^* = argmax_{b_0, b_1} sum\{(y_i - y_p)^2\}</script><p>其中, $y_p$ 为我们预测的值, $y_i$为真是值.</p><h1 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1. 数据预处理"></a>1. 数据预处理</h1><p>数据预处理,我们将按照第一天介绍的模型进行处理:</p><ol><li>导入相关库</li><li>导入数据集</li><li>检查缺失值</li><li>划分数据集</li><li>特征标准化</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">dataset = pd.read_csv(&quot;studentscores.csv&quot;)</span><br><span class="line">X = dataset.iloc[:, 0].values</span><br><span class="line">Y = dataset.iloc[:, 1].values</span><br><span class="line"></span><br><span class="line">from sklearn.cross_validation import train_test_split</span><br><span class="line">X_train, Y_train, X_test, Y_test = train_test_split(X, Y, test_size=1/4, random_state=0)</span><br></pre></td></tr></table></figure><h1 id="2-训练线性回归模型"><a href="#2-训练线性回归模型" class="headerlink" title="2. 训练线性回归模型"></a>2. 训练线性回归模型</h1><p>sklearn 机器学习库为我们提供了许多的常用机器学习模型,线性回归模型 LinearRegression 存在于 sklearn.linear_model 文件中, 该文件为我们提供了许多的线性模型.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">regressor = LinearRegression()</span><br><span class="line">regressor.fit(X_train, Y_train)</span><br></pre></td></tr></table></figure><p>我们首先通过 LinearRegression() 初始化一个 regressor 实例来表示线性回归模型.然后通过给 <code>.fit</code> 传入我们的训练集的特征和标签来训练 regressor.</p><p><strong>注意:</strong> 在 sklearn 中对训练数据的格式有一个规定,对于输入 X, 要求其格式是 N*M,其中 N 表示样本数, M 表示每个样本的特征数, 此示例中 M=1.对于标签 Y, 其格式是N*F, N表示样本数, F表示输出值的个数,此处F=1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(regressor.coef_, regressor.intercept_)</span><br></pre></td></tr></table></figure><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[9.94167834]] [1.93220425]</span><br></pre></td></tr></table></figure></p><p>regressor.coef_表示模型的权重, regressor.intercept_ 表示模型的偏执,分别表示上面模型公式的$b_1$ 和 $b_0$.</p><h1 id="3-预测结果"><a href="#3-预测结果" class="headerlink" title="3. 预测结果"></a>3. 预测结果</h1><p>当我们通过 <code>.fit</code> 函数训练好后模型,我们可以通过 <code>.predict</code> 函数来预测我们未知的数据.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y_pred = regressor.predict(X_test)</span><br></pre></td></tr></table></figure></p><p>我们通过手动预测来验证上面提到的 regressor.coef_, regressor.intercept_ 表示的意义:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp = regressor.intercept_[<span class="number">0</span>] + regressor.coef_[<span class="number">0</span>] * X_test[<span class="number">0</span>]</span><br><span class="line">print(temp, Y_pred[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[16.84472176] [16.84472176]</span><br></pre></td></tr></table></figure></p><h1 id="4-可视化"><a href="#4-可视化" class="headerlink" title="4. 可视化"></a>4. 可视化</h1><p>首先我们可视化训练集的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X_train, Y_train, color=&quot;red&quot;)</span><br><span class="line">plt.plot(X_train, regressor.predict(X_train), color=&apos;blue&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/images/simple_linear_regression_fig1.png" alt="figure1"><br>对测试集进行可视化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X_test, Y_test, color=&quot;red&quot;)</span><br><span class="line">plt.plot(X_test, regressor.predict(X_test), color=&quot;blue&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/images/simple_linear_regression_fig2.png" alt="figure2"></p><p>其中 <code>.scatter</code> 用于画散点图, <code>.plot</code> 用于画直线.</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://github.com/RanMaosong/RanMaosong.github.io" target="_blank" rel="noopener">感谢大家的阅读和支持, 欢迎大家上星.</a>.该博客的原始Github项目地址<a href="https://github.com/Avik-Jain/100-Days-Of-ML-Code/blob/master/Code/Day2_Simple_Linear_Regression.md" target="_blank" rel="noopener">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;相关链接:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://ranmaosong.github.io/2018/09/13/ML-100-Days-002/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github地址&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习100天" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"/>
    
    
      <category term="机器学习100天" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>数据预处理——Day 1</title>
    <link href="http://yoursite.com/2018/09/11/ML-100-Days-001/"/>
    <id>http://yoursite.com/2018/09/11/ML-100-Days-001/</id>
    <published>2018-09-11T02:53:21.000Z</published>
    <updated>2018-09-13T13:36:13.568Z</updated>
    
    <content type="html"><![CDATA[<p><strong>相关链接:</strong><br><a href="https://ranmaosong.github.io/2018/09/11/ML-100-Days-001/" target="_blank" rel="noopener">Github地址</a><br><a href="https://www.jianshu.com/p/b7b5512395f8" target="_blank" rel="noopener">简书地址</a><br><a href="https://blog.csdn.net/u014630987/article/details/82669796" target="_blank" rel="noopener">CSDN地址</a></p><hr><p>总所周知,对于机器学习任务,特别是对于深度学习任务,我们需要创建训练集,因此需要收集大量的数据.然而,在实际中,我们收集的数据极易受噪声、缺失值和数据不一致的影响。通常我们对数据进行如下几种预处理：</p><ol><li>缺失值处理</li><li>异常值处理</li><li>冗余数据处理</li><li>数据标准化</li><li>数据离散化</li><li>数据向量化: 我自己总结的，主要针对文本数据。不知道算不算预处理，但这是文本数据的必须操作。</li></ol><p>本文主要针对缺失值处理和数据向量化两种与处理方法进行讲解，整个处理过程分为6步：</p><ol><li>导入相关库</li><li>导入数据集</li><li>处理缺失值</li><li>编码分类数据</li><li>创建训练集和测试集</li><li>特征缩放</li></ol><p>下面我们将通过实例来一步步详细介绍这些操作。</p><h1 id="1-导入相关库"><a href="#1-导入相关库" class="headerlink" title="1. 导入相关库"></a>1. 导入相关库</h1><p><a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a> 和 <a href="https://pandas.pydata.org/" target="_blank" rel="noopener">pandas</a> 是利用 Python 进行科学计算时非常重要两个科学计算库。其中 numpy 负责提供基本的数学计算函数，起运算对象事针对张量或矩阵；而 pandas 库则用来导入和管理数据集。起导入规则如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h1 id="2-导入数据集"><a href="#2-导入数据集" class="headerlink" title="2. 导入数据集"></a>2. 导入数据集</h1><p>pandas 是一个管理数据的函数库，我为我们提供了许多读取和操作数据的接口:</p><p><img src="/images/pd_read_data.png" alt="pandas_read_data"></p><p><code>.csv</code> 格式文件是我们保存数据的一种常用格式，其格式简单，其默认格式是以 ,(英文逗号)分割数据集，显示效果和 excel 表格类似。 pandas 为我们提供了访问 <code>.csv</code> 的接口，其 <code>pd.read_csv()</code>用来进行读取 <code>.csv</code>格式数据,该函数常用的参数如下：</p><ul><li>filename: 文件名</li><li>header: 表头，默认不为空（第一行为表头），设为 None， 表示无表头</li><li>sep: 指定分隔符。如果不指定参数，则会尝试使用逗号分隔</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[ : , :<span class="number">-1</span>].values</span><br><span class="line">Y = dataset.iloc[ : , <span class="number">3</span>].values</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Avik-Jain/100-Days-Of-ML-Code/tree/master/datasets" target="_blank" rel="noopener">Data.csv</a>是我们访问的数据集,其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Country,Age,Salary,Purchased</span><br><span class="line">France,44,72000,No</span><br><span class="line">Spain,27,48000,Yes</span><br><span class="line">Germany,30,54000,No</span><br><span class="line">Spain,38,61000,No</span><br><span class="line">Germany,40,,Yes</span><br><span class="line">France,35,58000,Yes</span><br><span class="line">Spain,,52000,No</span><br><span class="line">France,48,79000,Yes</span><br><span class="line">Germany,50,83000,No</span><br><span class="line">France,37,67000,Yes</span><br></pre></td></tr></table></figure></p><p><code>pd.read_csv()</code>返回的数据类型为DataFrame（把他就像成一张表），其没有原始的下表操作，我们访问内容通过如下几个函数：</p><ol><li>loc: 通过行标签访问数据</li><li>iloc: 通过行索引进行访问</li><li>ix: loc 和 iloc 的混合</li></ol><p><code>.value</code> 属性则是将 DataFrame 转成 numpy类型，以便后续的数值计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(type(dataset), type(X), type(Y))</span><br><span class="line">print(X.shape, Y.shape)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; &lt;class &apos;numpy.ndarray&apos;&gt; &lt;class &apos;numpy.ndarray&apos;&gt;</span><br><span class="line">(10, 3) (10,)</span><br><span class="line">[[&apos;France&apos; 44.0 72000.0]</span><br><span class="line"> [&apos;Spain&apos; 27.0 48000.0]</span><br><span class="line"> [&apos;Germany&apos; 30.0 54000.0]</span><br><span class="line"> [&apos;Spain&apos; 38.0 61000.0]</span><br><span class="line"> [&apos;Germany&apos; 40.0 nan]</span><br><span class="line"> [&apos;France&apos; 35.0 58000.0]</span><br><span class="line"> [&apos;Spain&apos; nan 52000.0]</span><br><span class="line"> [&apos;France&apos; 48.0 79000.0]</span><br><span class="line"> [&apos;Germany&apos; 50.0 83000.0]</span><br><span class="line"> [&apos;France&apos; 37.0 67000.0]]</span><br></pre></td></tr></table></figure></p><h1 id="3-处理缺失值"><a href="#3-处理缺失值" class="headerlink" title="3. 处理缺失值"></a>3. 处理缺失值</h1><p>从数据集我们可以发现，某些数据为空，这时我们需要对这些缺失值进行处理。我么可以对缺失值进行均值和中值处理，即用整个数据集的该列数据的均值或中值来替换缺失的值。在sklearn的preprocessing包中包含了对数据集中缺失值的处理，主要是应用Imputer类进行处理。代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line">imputer = Imputer(missing_values = <span class="string">"NaN"</span>, strategy = <span class="string">"mean"</span>, axis = <span class="number">0</span>)</span><br><span class="line">imputer = imputer.fit(X[ : , <span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">X[ : , <span class="number">1</span>:<span class="number">3</span>] = imputer.transform(X[ : , <span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure></p><p>该代码首先导入 Imputer 类，然后通过一些参数来创建 Imputer 实例，参数意思大致如下：</p><ul><li>missing_values: 我们要处理的缺失值类型，由于 <code>pandas.read_csv()</code> 会将确实的值默认设置为 Nan，所以这里其类型为 <code>Nan</code>。</li><li>strategy： 表示采用何种策略，其取值有 mean, median, most_frequent,默认为 mean，即均值。</li><li>axis: 表示我们处理的方向，由于这里列方向是同一类型数据，即主轴方向，因此其值为0.</li></ul><p><strong>注意</strong>: sklearn 库预处理操作有个特征是，其处理分为两步： fit 和 transform，fit 大致可以理解为我们对那些数据进行操作或统计，transform 表示实际进行操作。这一点和 sklearn 中的机器学习算法类似，两个固定接口: fit 和 predict。</p><p>由于我们数据库中的数据只有第2、3 列才是数值数据，我们也只能对这两列数据进行预处理，所欲第三行我们在 <code>.fit</code> 中指出要操作的数据，在其内部分别计算了这两列的均值，以供后面处理使用。</p><p>第四行代码执行缺失值处理，通过第三行已经计算出 相应的均值，所以这行代码实际执行缺失值处理</p><p>第三行和第四行代码可以通过<code>.fit_transform</code> 函数来一步执行。这也是 sklearn 的一个特点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(X)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[&apos;France&apos; 44.0 72000.0]</span><br><span class="line"> [&apos;Spain&apos; 27.0 48000.0]</span><br><span class="line"> [&apos;Germany&apos; 30.0 54000.0]</span><br><span class="line"> [&apos;Spain&apos; 38.0 61000.0]</span><br><span class="line"> [&apos;Germany&apos; 40.0 63777.77777777778]</span><br><span class="line"> [&apos;France&apos; 35.0 58000.0]</span><br><span class="line"> [&apos;Spain&apos; 38.77777777777778 52000.0]</span><br><span class="line"> [&apos;France&apos; 48.0 79000.0]</span><br><span class="line"> [&apos;Germany&apos; 50.0 83000.0]</span><br><span class="line"> [&apos;France&apos; 37.0 67000.0]]</span><br></pre></td></tr></table></figure></p><h1 id="4-编码分类数据"><a href="#4-编码分类数据" class="headerlink" title="4. 编码分类数据"></a>4. 编码分类数据</h1><p>对于我们计算机进行科学计算只针对数值，而不能对文本进行数值计算，因此我们需要对文本进行数据向量化。如何用数值表示文本呢? 最常用的的格式就是 one-hot 格式,这种格式将文本表示成一个向量,该向量只有一个元素的值为1,其余全为0.</p><p>比如,我们数据集有”a”, “b”, “c”, “d”四个文本,此时我们的向量长度则为4,则这四个文本表示如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a: [1, 0, 0, 0]</span><br><span class="line">b: [0, 1, 0, 0]</span><br><span class="line">c: [0, 0, 1, 0]</span><br><span class="line">d: [0, 0, 0, 1]</span><br></pre></td></tr></table></figure></p><p>因此我们需要先统计数据库中所有的文本,并对每个文本从 0 开始进行编号.该过程也通过sklearn库来进行实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, OneHotEncoder</span><br><span class="line">labelencoder_X = LabelEncoder()</span><br><span class="line">X[ : , <span class="number">0</span>] = labelencoder_X.fit_transform(X[ : , <span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><p>由于对于特征(数据集中的最后一列是标签),只有第一列是文本,因此我们需要对第一列进行文本统计.上面代码就是将第一列的文本用自己的编号来进行表示.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(X)</span><br></pre></td></tr></table></figure><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[0 44.0 72000.0]</span><br><span class="line"> [2 27.0 48000.0]</span><br><span class="line"> [1 30.0 54000.0]</span><br><span class="line"> [2 38.0 61000.0]</span><br><span class="line"> [1 40.0 63777.77777777778]</span><br><span class="line"> [0 35.0 58000.0]</span><br><span class="line"> [2 38.77777777777778 52000.0]</span><br><span class="line"> [0 48.0 79000.0]</span><br><span class="line"> [1 50.0 83000.0]</span><br><span class="line"> [0 37.0 67000.0]]</span><br></pre></td></tr></table></figure></p><p>如何将这些编号表示的文本转换成one-hot形式呢?这就需要使用 sklearn.preprocessing 中的 OneHotEncoder 进行编号.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onehotencoder = OneHotEncoder(categorical_features = [<span class="number">0</span>])</span><br><span class="line">X = onehotencoder.fit_transform(X).toarray()</span><br><span class="line">labelencoder_Y = LabelEncoder()</span><br><span class="line">Y =  labelencoder_Y.fit_transform(Y)</span><br></pre></td></tr></table></figure></p><p>categorical_features 参数指定了我们需要对哪些列进行one-hot编码,这里为0,表示对第一列,然后利用’.fit_transform’ 进行编码.由于对于标签我们只需要其标签类型,因此不需要进行 one-hot 编码.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(X[<span class="number">0</span>])</span><br><span class="line">print(Y)</span><br></pre></td></tr></table></figure><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1.0e+00 0.0e+00 0.0e+00 4.4e+01 7.2e+04]</span><br><span class="line">[0 1 0 0 1 1 0 1 0 1]</span><br></pre></td></tr></table></figure></p><p>因为第一列总共有三种文本,因此其one-hot向量长度为3,且第一个样本的 index 为0, 故其 one-hot 为 [1, 0, 0],总的就如上所示.</p><h1 id="5-创建训练集和测试集"><a href="#5-创建训练集和测试集" class="headerlink" title="5. 创建训练集和测试集"></a>5. 创建训练集和测试集</h1><p>对于机器学习任务,我们需要将数据集按照比例划分成两个部分: 训练集和测试集.训练接用于训练模型,测试集用于测试我们模型的性能.对于数据的划分,我们使用 sklearn.cross_validation 的 train_test_split 对数据集按比例进行划分.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.cross_validation import train_test_split</span><br><span class="line">X_train, X_test, Y_train, Y_test = train_test_split( X , Y , test_size = 0.2, random_state = 0)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(X.shape, X_train.shape, X_test.shape)</span><br></pre></td></tr></table></figure><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(10, 5) (8, 5) (2, 5)</span><br></pre></td></tr></table></figure></p><h1 id="6-特征缩放"><a href="#6-特征缩放" class="headerlink" title="6. 特征缩放"></a>6. 特征缩放</h1><p>通过我们需要对数据进行标准化处理,这样可以减小噪声的影响.通常将其标准化为:均值为0, 方差为1的数据范围.<br>标准化之前的方差和均值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(np.mean(X_train), np.std(X_train))</span><br><span class="line">print(np.mean(X_test), np.std(X_test))</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12527.338888888888 25395.495797239782</span><br><span class="line">13708.2 28152.896706378193</span><br></pre></td></tr></table></figure></p><p>进行标准化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">sc_X = StandardScaler()</span><br><span class="line">X_train = sc_X.fit_transform(X_train)</span><br><span class="line">X_test = sc_X.fit_transform(X_test)</span><br></pre></td></tr></table></figure></p><p>标准化之后的均值和方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(np.mean(X_train), np.std(X_train))</span><br><span class="line">print(np.mean(X_test), np.std(X_test))</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7.771561172376095e-17 1.0</span><br><span class="line">0.0 0.6324555320336759</span><br></pre></td></tr></table></figure></p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://github.com/RanMaosong/RanMaosong.github.io" target="_blank" rel="noopener">感谢大家的阅读和支持, 欢迎大家上星.</a>.该博客的原始Github项目地址[点击这里]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;相关链接:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://ranmaosong.github.io/2018/09/11/ML-100-Days-001/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github地址&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习100天" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"/>
    
    
      <category term="机器学习100天" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>序言</title>
    <link href="http://yoursite.com/2018/09/10/ML-100-Days/"/>
    <id>http://yoursite.com/2018/09/10/ML-100-Days/</id>
    <published>2018-09-10T03:16:16.000Z</published>
    <updated>2018-09-13T13:34:39.533Z</updated>
    
    <content type="html"><![CDATA[<p><strong>相关链接:</strong><br><a href="https://ranmaosong.github.io/2018/09/10/ML-100-Days/" target="_blank" rel="noopener">Github地址</a><br><a href="https://www.jianshu.com/p/ee8fc3881c57" target="_blank" rel="noopener">简书地址</a><br><a href="https://blog.csdn.net/u014630987/article/details/82669779" target="_blank" rel="noopener">CSDN地址</a></p><p>该系列博客是基于由<a href="https://github.com/llSourcell" target="_blank" rel="noopener">Siraj Raval</a>提出的<a href="https://github.com/Avik-Jain/100-Days-Of-ML-Code" target="_blank" rel="noopener">100 Days of Machine Learning Coding</a>.而该系列博客的目的是在学习该项目的同事丰富其内容，加入自己查阅的资料和自己的理解。该项目全部基于 Python 语言进行讲解</p><p><strong>内容安排</strong></p><ul><li><a href="https://ranmaosong.github.io/2018/09/11/ML-100-Days-001/" target="_blank" rel="noopener">第1天 数据集预处理</a></li><li><a href="/2018/09/13/ML-100-Days-002/">第2天 简单线性回归</a></li><li><a href="*">第3天 多元线性回归</a></li><li><a href="*">第4天 Logistic回归</a></li><li><a href="*">第5天 Logistic回归</a></li><li><a href="*">第6天 实现 Logistic回归</a></li><li><a href="*">第7天 K 均值</a></li><li><a href="*">第8天 Logistic回归数学原理</a></li><li><a href="*">第9天 支持向量机</a></li><li><a href="*">第10天 实现 K 均值</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;相关链接:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://ranmaosong.github.io/2018/09/10/ML-100-Days/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github地址&lt;/a&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习100天" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"/>
    
    
      <category term="机器学习100天" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2018/08/14/Algorithm-sorting/"/>
    <id>http://yoursite.com/2018/08/14/Algorithm-sorting/</id>
    <published>2018-08-14T14:22:27.000Z</published>
    <updated>2018-08-14T14:57:29.883Z</updated>
    
    <content type="html"><![CDATA[<p><strong>排序</strong>就是将一组无序的元素通过某种规则将他们按照某种主键来进行升序或者降序排列，比如，我们考试成绩，按照总分进行降序排列，按照语文成绩进行降序排列，按照数学成绩进行降序排列，此时的<em>总分</em>, <em>语文</em>, <em>数学</em> 就是我们排序的主键,又或者我们打开电脑文件夹,按照名字排序,按照时间排序等,由此可见,排序操作在我们的日常生活中的作用之大,下面我们将讲解一些常见的排序算法,参考书籍为<strong>&lt;&lt;算法 第四版&gt;&gt;</strong>.</p><p><strong>声明</strong>: 本节所有内容均默认以升序排列,同时所有代码遵从以下模板.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        String[] a = new String[n];</span></span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">assert</span> Template.isSorted(a);</span><br><span class="line">        Template.show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>选择排序</strong> 顾名思义就是从乱序的数组中选择最值,其思路如下: 首先,从 N 个数中选择最小的数,放在数组第一个位置,然后从剩下的 N-1 个数中选择最小的数放在数组的第二个位置,迭代此过程直至完成排序.该算法大约进行 $N^2/2$ 次比较和 N 次交换,详细计算如下:</p><p>寻找第一个最小值时,我们需要在余下的 N-1(为什么是 N-1 不是 N?因为数组坐标为0的数是我们目前最小的值,此时我们从剩下的 N-1 个数比较依次找最小值) 个数中进行比较,且交换 1 次,此时进行了 N-1 次比较,寻找第二个最小值时,需要在余下的 N-2 个数中进行比较,此时进行了 N-2 次比较,所以我们总共需要 $(N-1)+(N-2)+\dots +1=N(N-1)/2$ 比较和 N-1 次交换.</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> song</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 18-8-14 下午9:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 升序排列</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Template.less(a[j], a[min]))</span><br><span class="line">                    min = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Template.exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] a = <span class="keyword">new</span> String[]&#123;<span class="string">"s"</span>, <span class="string">"o"</span>, <span class="string">"r"</span>, <span class="string">"t"</span>, <span class="string">"e"</span>, <span class="string">"x"</span>, <span class="string">"a"</span>, <span class="string">"m"</span>, <span class="string">"p"</span>, <span class="string">"l"</span>, <span class="string">"e"</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="keyword">assert</span> Template.isSorted(a);</span><br><span class="line">        Template.show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;就是将一组无序的元素通过某种规则将他们按照某种主键来进行升序或者降序排列，比如，我们考试成绩，按照总分进行降序排列，按照语文成绩进行降序排列，按照数学成绩进行降序排列，此时的&lt;em&gt;总分&lt;/em&gt;, &lt;em&gt;语文&lt;/em&gt;, &lt;em&gt;数
      
    
    </summary>
    
      <category term="Algorithm(4th)" scheme="http://yoursite.com/categories/Algorithm-4th/"/>
    
    
      <category term="Algorithm(4th)" scheme="http://yoursite.com/tags/Algorithm-4th/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串(Longest Palindromic Substring)</title>
    <link href="http://yoursite.com/2018/04/10/LeetCode-001-LongestPalindromicSubstring/"/>
    <id>http://yoursite.com/2018/04/10/LeetCode-001-LongestPalindromicSubstring/</id>
    <published>2018-04-10T13:05:49.000Z</published>
    <updated>2018-10-06T06:27:45.892Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ranmaosong.github.io/2018/04/10/001-LeetCode-LongestPalindromicSubstring/" target="_blank" rel="noopener">Github地址</a><br><a href="https://www.jianshu.com/p/c0840c4d03be" target="_blank" rel="noopener">简书地址</a><br><a href="https://blog.csdn.net/u014630987/article/details/79948604" target="_blank" rel="noopener">CSDN地址</a></p><p><strong>问题描述</strong></p><p><strong>给定一个字符串 s，找出其中最长的回文子串，假设给定字符串的长度最大维 1000.</strong></p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意： “aba” 也是正确的解，有多个解返回其中一个即可</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p>回文串是指一个字符串对称，从最左边和最右边分别往最中间遍历，各个位置的字符都相同。解决这个问题，下面将从四个算法分别进行介绍。</p><p><strong>1、暴力枚举法（不可取）</strong></p><p>暴力枚举法是最简单、最容易想到的方法，其思路是：首先找到字符串 s 的所有子串，然后判断该子串是否是回文字符串，最后返回最长的回文子串。该方法虽然简单明了，但因其计算成本太高，该算法在实际中并<strong>不可取</strong>。</p><p>由于一个长为 n 的字符串，共有 $\frac{n(n+1)}{2}$ 个连续子串，故寻找子串的时间复杂度为 $O(n^2)$, 判断一个字符串是否维回文串的时间复杂度维 $O(n)$,故</p><p><strong>时间复杂度:</strong> $O(n^3)$</p><p><strong>空间复杂度为:</strong> $O(1)$。</p><p>下面是 Java 的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestPalindromicSubstring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存得到的最长回文子串的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;len; ++j) &#123;</span><br><span class="line">                <span class="comment">// 获取 s 的连续子串</span></span><br><span class="line">                String subStr = s.substring(i, j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断子串是否是回文字符串</span></span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(subStr)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j-i &gt; right-left) &#123;</span><br><span class="line">                        left = i;</span><br><span class="line">                        right = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(left, right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、中心扩展法（可取）</strong></p><p>中心扩展法是根据暴力枚举法改进而来，主要是去除了一些不必要的子字符串的判断，<strong>主要思路:</strong>首先从字符串 s 中选择一个字符作为子字符串的中心字符,然后以该字符维中心依次往左右两边扩展,判断该子串的最左边和最右边的字符是否相同,相同则继续向两边扩展,不相同则停止扩展,该子串则是以该字符为中心的最长回文子串,这样就减少了很多在暴力枚举方法中不必要的字符的判断.</p><p>和暴力枚举方法比较,以”abacdfgdcaba”为例,假设我们以第一个字符 ‘c’ 为中心,中心扩展首先比较”acd”,由于 ‘a’ 和 ‘d’不相同,则停止扩展,二暴力枚举还需比较 “bacdf” 和 “abacdfg”.该算法在扩展时需要同时考虑子串是奇数和偶数的情况.</p><p>由于需要依次迭代每个字符串中心,因此该迭代需要 $O(n)$ 时间复杂度,同时从中心向两边扩展的复杂度维 $O(n)$,因此:</p><p><strong>时间复杂度:</strong> $O(n^2)$</p><p><strong>空间复杂度为:</strong> $O(1)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestPalindromicSubstring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> test().longestPalindrome(<span class="string">"abacdfgdcaba"</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> test().longestPalindrome(<span class="string">"cbbd"</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> test().longestPalindrome(<span class="string">"babad"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存获得的最大回文子串</span></span><br><span class="line">        String maxStr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            String subStr1 = isPalindrome(s, i, i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (subStr1.length() &gt; maxStr.length()) &#123;</span><br><span class="line">                maxStr = subStr1;</span><br><span class="line">            &#125;</span><br><span class="line">            String subStr2 = isPalindrome(s, i, i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (subStr2.length() &gt; maxStr.length()) &#123;</span><br><span class="line">                maxStr = subStr2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// i 表示中心扩展的左边字符</span></span><br><span class="line">        <span class="comment">// j 表示中心扩展的右边字符</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            --i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  s.substring(i+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、动态规划（可取）</strong></p><p>回文字符串的子串也是回文字符串,我们可以将最长回文子串分解为一些列子问题,使用动态规划.设 f 为状态表,f(i,j)表示字符区间 [i, j](包括j)是否为回文字符串<br>,f(i, j)=false 表示子串 [i, j] 不是回文字符串,f(i, j)=true 表示子串 [i, j] 为回文字符串.当我们判断了字符 [i], [j] 相同时,只需判断 f(i+1, j-1) 是否维 true 即可.</p><p>状态表满足以下关系:</p><script type="math/tex; mode=display">f(i,j)=\begin{cases}true,\quad i=j \\s[i]==s[j], \quad i= j-1 \\s[i] = s[j]\quad and\quad f(i+1, j-1), \quad i< j-1\end{cases}</script><p>由于状态表 f 是一个 n*n 的方阵,且是一个对称方阵,故我们只需判断状态表 f 的右上角的内容,因此:</p><p><strong>时间复杂度:</strong> $O(n^2)$<br><strong>空间复杂度:</strong> $O(n^2)$</p><p>实现代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> test().longestPalindrome(<span class="string">"abacdfgdcaba"</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> test().longestPalindrome(<span class="string">"cbbd"</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> test().longestPalindrome(<span class="string">"babad"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j) &#123;</span><br><span class="line">            f[j][j] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;j; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (i == j-<span class="number">1</span> || f[i+<span class="number">1</span>][j-<span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j-i &gt; right - left) &#123;</span><br><span class="line">                        left = i;</span><br><span class="line">                        right = j;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    f[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(left, right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该代码首先将状态表全部初始化为 false, 然后按照从上到下,从左到右的顺序依次判断状态表的值.<br><strong>4、Manacher 算法（马拉车算法）（可取）</strong></p><p>Manacher 算法是一种经典的求取最长回文子串的方法,其基本原理是使用已知回文字符串的左半部分来推导以右半部分的字符为中心的回文字符.</p><p>我们使用 p[i] 表示以第 i 个字符为中心的最长回文半径.可以利用已知p[0],p[1]……p[i-1]的值,来计算 p[i] 的值.我们定义 maxRight 是当前计算 i 位置时所有回文子串所能达到的最右端的位置,且该回文串的中心位置为 k,此时有如下关系: maxRight = k + p[k],此时有两种情况:</p><p><img src="/images/longestPalindromicSubstring.png" alt="pictures001"></p><p><strong>第一种情况</strong>:i &gt; maxRight,此时初始化p[i] = 1, 然后判断s[i+p[i]] == s[i-p[i]],若不相等则停止,若相等,则++p[i]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (i &gt; maxRight) &#123;</span><br><span class="line">    p[i] = 1;</span><br><span class="line">    while(s[i+p[i]] == s[i-p[i]]) &#123;</span><br><span class="line">        ++p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>第二种情况</strong>:i &lt;= maxRight,此时不在给 p[i] 赋值维为1,由回文串的对称性可得, 2k-i 是 i 关于 k 的对称点.此时由两种情况:</p><ol><li>以 2k-i 为中心的回文串的半径(如图蓝色箭头)大于等于 $maxRight - i$(空心箭头),由对称性可知,已知紫色箭头 5 和 6 关于 k 对称,且 2k-i 和 i 关于 k 对称,所以空心箭头 1 和 4 对称,2 和 3 对称,又箭头 7 和 8 对称,且箭头 1 和 2 分别是 7 和 8 的一部分,所以空心箭头 1 和 2 对称,故空心箭头 3 和 4 对称.所以p[i]的对称半径至少为 maxRight - i.所以首先 p[i]=maxRight - i,然后在依次往两边扩展判断是否对称.</li></ol><p><img src="/images/LongestPalindroomicSubstring1.jpg" alt="picture2"></p><ol><li>以 2k-i 为中心的回文半径小于 maxRight-i,根据和上面类似的推导,可以得知 p[i] = p[2k-i],且不在扩展.</li></ol><p><img src="/images/LongestPalindroomicSubstring2.png" alt="picture3"></p><p>复杂度分析:</p><ul><li><strong>时间复杂度:</strong>$O(n)$</li><li><strong>空间复杂度:</strong> $O(n)$ </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> test().longestPalindrome(<span class="string">"abacdfgdcaba"</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> test().longestPalindrome(<span class="string">"cbbd"</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> test().longestPalindrome(<span class="string">"babad"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder temp = <span class="keyword">new</span> StringBuilder(<span class="string">"#"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            temp.append(s.charAt(i));</span><br><span class="line">            temp.append(<span class="string">"#"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String str = temp.toString();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * maxCenter: 保存当前能延伸到最右端的回文字符串的中心位置</span></span><br><span class="line"><span class="comment">        * maxId: 保存当前最长回文子串的中心位置</span></span><br><span class="line"><span class="comment">        * p: 保存以该位置的字符维中心位置的最长回文字符的右边长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> maxCenter=<span class="number">0</span>, maxId=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> syncCenter = <span class="number">2</span> * maxCenter - i;</span><br><span class="line">            p[i] = (i&lt;maxCenter + p[maxCenter) ? Math.min(p[syncCenter], maxCenter + p[maxCenter] - i) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i-p[i] &gt;=<span class="number">0</span> &amp;&amp; i+p[i]&lt;n &amp;&amp; str.charAt(i-p[i]) == str.charAt(i+p[i])) &#123;</span><br><span class="line">                ++p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt;= p[maxCenter] + maxCenter) &#123;</span><br><span class="line">                maxCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; p[maxId]) &#123;</span><br><span class="line">                maxId = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring((maxId - p[maxId])/<span class="number">2</span>, (maxId + p[maxId]) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://ranmaosong.github.io/2018/04/10/001-LeetCode-LongestPalindromicSubstring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github地址&lt;/a&gt;&lt;b
      
    
    </summary>
    
      <category term="Weekly Algorithm" scheme="http://yoursite.com/categories/Weekly-Algorithm/"/>
    
    
      <category term="Weekly Algorithm" scheme="http://yoursite.com/tags/Weekly-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>issue_mathjax</title>
    <link href="http://yoursite.com/2018/04/08/issue-mathjax/"/>
    <id>http://yoursite.com/2018/04/08/issue-mathjax/</id>
    <published>2018-04-08T13:50:26.000Z</published>
    <updated>2018-04-08T13:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>$c^{T}x^{<em>}=y^{T}Ax^{</em>}=y^{*T}b$</p><script type="math/tex; mode=display">c^{T}x^{*}=y^{T}Ax^{*}=y^{*T}b</script><p>$c_x=yAx=y_b$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$c^{T}x^{&lt;em&gt;}=y^{T}Ax^{&lt;/em&gt;}=y^{*T}b$&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;c^{T}x^{*}=y^{T}Ax^{*}=y^{*T}b&lt;/script&gt;&lt;p&gt;$c_x=yAx=y_b$
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring（二） —— 核心： 依赖注入</title>
    <link href="http://yoursite.com/2018/03/20/002-Spring-IoC/"/>
    <id>http://yoursite.com/2018/03/20/002-Spring-IoC/</id>
    <published>2018-03-20T14:05:32.000Z</published>
    <updated>2018-04-08T13:36:44.590Z</updated>
    
    <content type="html"><![CDATA[<p>在所有的 Java 程序中，总存在 A 对象调用 B 对象， B 对象调用 C 对象，这种情形被 Spring 称为依赖，即 A 对象依赖 B 对象，B 对象依赖 C 对象。对于整个 Java 项目而言，它是由一些相互调用的对象所构成， Spring 把这种相互调用的关系称为依赖关系。</p><p>Spring 提供的核心功能有两个：</p><ol><li>Spring容器作为一个超级大工厂，负责创建、管理所有的Bean（Java对象）；</li><li>Spring容器管理容器中Bean之间的依赖关系，它使用一种称为“依赖注入”的方式来管理 Bean 之间的依赖关系。</li></ol><p>依赖注入是一种优秀的解耦方法，使用依赖注入，程序中的各个组件不需要以硬编码的方式耦合在一起，同时不再需要工厂模式，我们只需使用配置文件就可将各个组件组织在一起。使用依赖注入，不仅可以为Bean注入普通的属性值，还可以注入其它 Bean 的引用。</p><h2 id="一、理解依赖注入"><a href="#一、理解依赖注入" class="headerlink" title="一、理解依赖注入"></a>一、理解依赖注入</h2><p>依赖注入(Dependency Injection)最开始的时候被称为控制反转(Inversion of Control,IoC).在传统方法中，我们主要有两种方式来实现依赖注入：</p><pre><code>1. 原始方法：调用者通过被调用对象的构造函数主动创建以来对象，在调用被依赖对象的方法；2. 工厂方法：调用者通过被依赖对象的的工厂方法来调用其方法； </code></pre><p>第一种方法，调用者通过“new”来创建被依赖对象，当被依赖对象做出更改时，必须修改调用者中的代码，这种以硬编码方法的耦合，非常不利于项目的升级维护。</p><p>工厂方法，大致分为三点：1、调用者面向被依赖对象的借口编程，2、被依赖对象的创建交给工厂实现，3、 调用者通过工厂来获得被依赖对象。但是这种方法会将工厂方法和被依赖对象耦合在一起。</p><p>由于Spring容器负责将被依赖对象赋值给调用者的成员变量，这样调用者无需主动获取被依赖对象，，这样对象间的耦合就通过配置文件来实现。</p><p>总之，Spring 框架的优点有：</p><pre><code>1. 程序无需主动使用 new 调用构造器来创建依赖对象，所有的java对象可交给 Spring 容器去创建。2. 调用者需要调用被依赖对象的方法时，调用者无需主动获取被依赖对象，Spring 容器会注入依赖对象。</code></pre><p>依赖注入有两种方式：</p><pre><code>1. 设值构造： IoC 容器使用成员变量的 setter 方法来注入被依赖对象。2. 构造注入： IoC 容器使用构造器来注入被依赖对象。</code></pre><h2 id="二、设值注入"><a href="#二、设值注入" class="headerlink" title="二、设值注入"></a>二、设值注入</h2><p>设置注入是指 IoC 容器通过成员变量的 setter 方法来注入被依赖对象，这种方法简单、直观，且大量使用。Spring 容器推荐面向接口编程，不管是调用者还是被依赖对象，都应该定义为借口，程序面向他们的借口编程而不是实现类编程。面向借口编程，可以更好地让规范和实现分离，从而更好的解耦，对于 Java EE，不管是 DAO组件还是应用业务逻辑组件，都应该先定义一个借口，来规范该组件应该实现的功能。</p><p>下面我们先定义两个接口在分别实现这两个接口。</p><p>1、 Person 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个使用斧头的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>Axe 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Axe 借口中定义一个 chop() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Chinese 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="comment">// 设值注入所需的setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 axe 的chop方法</span></span><br><span class="line">        <span class="comment">// 表明 Person 对象依赖于 axe 对象</span></span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>StoneAxe 类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoneAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"石头砍柴好慢"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>此时，我们已创建好所有的 Java 类，但是他们都还不是 Bean， Spring 也不知道哪些类相互耦合和相互依赖，这时我们需要使用 XML 配置文件来指定实例之间的依赖关系。Spring 2.0 开始，采用 XML Schema 来定义配置文件的语义约束。</p><p>XML 配置文件的内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置 chinese 实例，其实现类是 Chinese 类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"chinese"</span> <span class="attr">class</span>=<span class="string">"demo1.Chinese"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--驱动调用 chinese 的 setAxe 方法，将容器中的stoneAxe 作为参数传入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"axe"</span> <span class="attr">ref</span>=<span class="string">"stoneAxe"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"stoneAxe"</span> <span class="attr">class</span>=<span class="string">"demo1.StoneAxe"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Spring 配置 Bean 实例时必须指定两个属性：</p><ol><li>id： 该 Bean 的唯一标志，Spring 根据 id 属性来管理 Bean，程序通过 id 属性值来访问该 Bean；</li><li><p>class: 指定该 Bean 的实现类，此处不可一世借口，必须是实现类，因为借口不可以实例化。</p><p>Spring 会自动检测每个 <bean...>定义里面的<property...>元素，Spring 会在自动调用默认构造器创建实例之后，立即调用对应的setter方法维 Bean 的成员变量注入值。</property...></bean...></p><p>下面的代码通过 ApplicationContest 的子类 ClassPathXmlApplicationContext 来获取 Person 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建容器</span></span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans1.xml"</span>);</span><br><span class="line">        <span class="comment">//获取 chinese 实例</span></span><br><span class="line">        Person p = ctx.getBean(<span class="string">"chinese"</span>, Chinese.class);</span><br><span class="line">        <span class="comment">// 调用 useAxe() 方法</span></span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>石头砍柴好慢</p></blockquote></li></ol><p>如果某一天，系统需要改变 Axe 的实现，比如 SteelAxe 类，此时只需给出 Axe 的另一个类和更改 XML 配置文件，而Person、Chinese类如需任何改动。</p><p>SteelAxe 类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>XML 配置文件更改如下：<br>添加一行<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"steelAxe"</span> <span class="attr">class</span>=<span class="string">"demo1.SteelAxe"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>将<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"axe"</span> <span class="attr">ref</span>=<span class="string">"stoneAxe"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>改成：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"axe"</span> <span class="attr">ref</span>=<span class="string">"steelAxe"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>输出：</p><blockquote><p>钢斧砍柴真快</p></blockquote><p>从上面的变化可以看出，chinese 实例与具体的 Axe 实现类没有任何联系，chinese 实例只与 Axe 借口耦合，这就是 Spring 强调面向借口编程的原因。</p><h2 id="三、构造注入"><a href="#三、构造注入" class="headerlink" title="三、构造注入"></a>三、构造注入</h2><h2 id="四、对比两种方式"><a href="#四、对比两种方式" class="headerlink" title="四、对比两种方式"></a>四、对比两种方式</h2><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>Spring IoC容器的三个基本要点：</p><ol><li><p>应用程序各组件面向借口编程。面向接口编程可以讲组件之间的耦合关系提升到借口层次，从而有利于项目的后期维护。</p></li><li><p>应用程序的各组件不在有程序主动创建，而是由 Spring 容器负责产生并初始化。</p></li><li><p>Spring 采用配置文件或注解来管理 Bean 的实现类、依赖关系， Spring容器则根据配置文件或注解，利用反射机制来创建实例，并为之注入依赖关系</p></li></ol><p>$c^{T}x^{<em>}=y^{T}Ax^{</em>}=y^{*T}b$</p><script type="math/tex; mode=display">c^Tx^*=y^{T}Ax^*=y^{*T}b</script><p>2</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在所有的 Java 程序中，总存在 A 对象调用 B 对象， B 对象调用 C 对象，这种情形被 Spring 称为依赖，即 A 对象依赖 B 对象，B 对象依赖 C 对象。对于整个 Java 项目而言，它是由一些相互调用的对象所构成， Spring 把这种相互调用的关系称
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring（一） —— 入门</title>
    <link href="http://yoursite.com/2018/03/17/001-Spring-Introduction/"/>
    <id>http://yoursite.com/2018/03/17/001-Spring-Introduction/</id>
    <published>2018-03-17T11:25:00.000Z</published>
    <updated>2018-03-20T14:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明</strong>：本教程均在Spring4.0.4版本中实现</p><p>目前Java EE主流的轻量级开发框架有SSH(Struts+spring+Hibernate)和SSM(Spring+Sprng MVC+Mybatis),从中可以看出，无论是SSH还是SSM，Spring在Java开发中有着重要的作用。</p><p>Spring以IoC、AOP维主要思想，它是一个“一站式”框架，即在 Java EE的三层架构，即表现层（Web层）、业务逻辑层（Service层）、数据访问层（DAO）层中，每一层均提供了不同的解决技术。</p><p>当使用Spring框架时，必须使用Spring Core Container（即Spring容器），它是Spring的核心机制，主要由org.springframework.core、org.springframework.beans、org.springframework.context、prg.springframework.expression四个包及其子包组成，主要提供Spring IoC容器支持。</p><h2 id="一-Maven依赖"><a href="#一-Maven依赖" class="headerlink" title="一 Maven依赖"></a>一 Maven依赖</h2><p>本教程全都基于Maven管理工具来构建基于 Spring 框架的应用，因此基础Maven依赖主要包括三个spring-core、spring-context、spring-beans<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring-beans --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="二-Spring-Bean概念"><a href="#二-Spring-Bean概念" class="headerlink" title="二 Spring Bean概念"></a>二 Spring Bean概念</h2><p>Spring 核心容器像是一个超级大工厂，所有的Java对象都会成为 Spring 核心容器的管理对象，Spring把容器中的一切管理对象成为Bean。</p><p>Spring容器中的Bean和Java Bean不同，它不需要像 Java Bean 那样遵守一些规范，Spring对Bean没有任何的要求。<strong>在 Spring 中，一切 Java 对象，都是Bean</strong>。</p><p>下面我们先创建一个简单的 Java 类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.crazyit.app.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"使用斧头劈柴"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着我们在创建一个 Person 类，在 Person 类的 useAxe() 方法中使用 Axe 对象的 chop() 方法，这样 Person 对象就依赖于 Axe对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.crazyit.app.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;zhong</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我打算去砍点柴火！"</span>);</span><br><span class="line">        <span class="comment">// 调用 axe 的 chop() 方法</span></span><br><span class="line">        <span class="comment">// 表明 Person 对象依赖于 axe 对象</span></span><br><span class="line">        System.out.print(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们创建好 Java 类后，如何让它们成为Spring Bean，这就要通过XML配置文件或者注解来让 Spring 管理这些 Bean，该配置文件内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!--  Spring 配置文件的根元素没使用spring-beans-4.0.xsd 语义约束--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置名为person的Bean，其实现类为org.crazyit.app.service.Person--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.crazyit.app.service.Person"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--控制调用setAxe()方法，将容器的名为axe的Bean作为参数传入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"axe"</span> <span class="attr">ref</span>=<span class="string">"axe"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置名为axe的Bean，其实现类为org.crazyit.app.service.Axe--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"axe"</span> <span class="attr">class</span>=<span class="string">"org.crazyit.app.service.Axe"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置名为win的Bean，其实现类为javax.swing.JFrame--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"win"</span> <span class="attr">class</span>=<span class="string">"javax.swing.JFrame"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置名为date的Bean，其实现类为java.util.Date--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>该配置文件的根元素维<bean...>,它包括多个<bean...>元素，每个<bean...>元素定义一个Bean，上面的配置文件共定义了四个Bean，其中两个为我们自定义的 Java 类，后面两个使用了 JDK 标准库中的类，这和前面说的 <strong>Spring中,一切 Java 对象皆可为 Bean</strong>一致。</bean...></bean...></bean...></p><p>我们通过如下元素来将 Java 类变为 Bean，<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置名为axe的Bean，其实现类为org.crazyit.app.service.Axe--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"axe"</span> <span class="attr">class</span>=<span class="string">"org.crazyit.app.service.Axe"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中 id 属性为该 Bean 指定了唯一标志，class 属性指定该Bean要实现哪个类，这个类可以是任何 Java 类：自定义类和标准库类都可以。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置名为person的Bean，其实现类为org.crazyit.app.service.Person--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.crazyit.app.service.Person"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--控制调用setAxe()方法，将容器的名为axe的Bean作为参数传入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"axe"</span> <span class="attr">ref</span>=<span class="string">"axe"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><bean...> 元素还可以包含多个 <property...> 子元素。它用来设置该 Bean 的属性的值，通过调用setter方法来实现，name 属性指定要设置哪个属性的值，ref或value属性决定使用什么内容来作为参数：</property...></bean...></p><ol><li>ref 表示使用容器中的某个 Bean 来作为 setter 的参数；</li><li>value 指明使用内置对象及其包装类来作为setter参数</li></ol><p><strong>底层浅析：</strong></p><p>1.<bean...> 元素默认以反射方式来调用该类的无参构造函数创建 Bean； 其实现方式类似如下代码，以 id 为 person 的Bean为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String idStr = ...; <span class="comment">// 解析&lt;bean.../&gt;元素的id属性得到该字符串值“person”</span></span><br><span class="line">string classStr = ...; <span class="comment">//解析&lt;bean.../&gt;元素的 class 属性得到该字符串值“org.crazyit.app.service.Person”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clazz</span> </span>= Class.forName(classStr);</span><br><span class="line">Object obj = <span class="class"><span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line"><span class="comment">// container 代表 Spring 容器</span></span><br><span class="line">container.put(idStr, obj);</span><br></pre></td></tr></table></figure></bean...></p><ol><li><property...>也是通过反射机制来调用对象的 setter 方法来实现的，实现方式如下，以 id 为 person 的Bean为例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String nameStr = ...; <span class="comment">// 解析&lt;property .../&gt;元素的name属性，得到该属性值“axe”</span></span><br><span class="line">String refStr = ...; <span class="comment">//解析&lt;property.../&gt;元素的ref属性得到字符串“axe”</span></span><br><span class="line">String setterName = <span class="string">"set"</span> + nameStr.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + nameStr.substring(<span class="number">1</span>); <span class="comment">//生成要调用的setter方法名</span></span><br><span class="line"><span class="comment">//获取容器中名为refStr的Bean，</span></span><br><span class="line">Object paramBean = container.get(refStr);</span><br><span class="line">Method setter = clazz.getMethos(setterName, paramBean,getClass());</span><br><span class="line">setter.incoke(obj, paramBean)</span><br></pre></td></tr></table></figure></property...></li></ol><h2 id="三-访问-Bean"><a href="#三-访问-Bean" class="headerlink" title="三 访问 Bean"></a>三 访问 Bean</h2><p>我们在xml配置文件中配置好Bean和它们的相关依赖后，我们需要通过Spring容器来访问容器中的Bean。<code>ApplicationContext</code>是Spring容器最常用的接口，他有两个实现类：</p><ol><li>ClassPathXmlApplicationContext：该类从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器；</li><li>FileSystemXmlApplicationContext：该类从文件系统的相对路径或者绝对路径下去搜索配置文件；</li></ol><p>对于应用程序，类加载路径总是不变的，因此通常用ClassPathXmlApplicationContext来创建Spring容器 。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.crazyit.app.service.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Spring容器</span></span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        <span class="comment">//获取id为person的Bean</span></span><br><span class="line">        Person p = ctx.getBean(<span class="string">"person"</span>, Person.class);</span><br><span class="line">        <span class="comment">// 调用useAxe() 方法</span></span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过Spring容器来获取Bean对象主要由两个方法：</p><ol><li>Object getBean(String id): 根据容器中Bean的id来获取Bean，该方法需要强制类型转换。</li><li>T getBean(String id, Class <t> requiredType):根据容器中Bean的id来获取Bean，该方法无需进行强制类型转换。</t></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：本教程均在Spring4.0.4版本中实现&lt;/p&gt;
&lt;p&gt;目前Java EE主流的轻量级开发框架有SSH(Struts+spring+Hibernate)和SSM(Spring+Sprng MVC+Mybatis),从中可以看出，无论
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch Deep Learning for NLP with Pytorch</title>
    <link href="http://yoursite.com/2018/01/20/PyTorch-Deep-Learning-for-NLP-with-Pytorch/"/>
    <id>http://yoursite.com/2018/01/20/PyTorch-Deep-Learning-for-NLP-with-Pytorch/</id>
    <published>2018-01-20T14:04:52.000Z</published>
    <updated>2018-03-20T14:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>此教程翻译自<a href="http://pytorch.org/tutorials/beginner/deep_learning_nlp_tutorial.html" target="_blank" rel="noopener">官方教程</a></p><p><strong>作者:</strong><a href="https://github.com/rguthrie3/DeepLearningForNLPInPytorch" target="_blank" rel="noopener">Robert Guthrie</a></p><p>本教程将引导您学习在使用 Pytorch 进行深度学习编程中的一些主要思想。许多概念（概念图抽象和autograd）并不是 Pytorch 所特有的，而是与任何深度学习工具有关。</p><p>我写这个教程，专门针对自然语言处理和那些从未用过任何深度学习框架（比如Tensorflow,Theano,Keras, Dynet)的写过自然语言处理的人。该教程假定你知道自然语言处理的核心知识： 词性标注、语言建模等。也假定你熟悉神经网络基础（例如来自 Russel 和 Norvig书）。通常，这些书籍涵盖基础的前馈神经网络的反向传播算法，并指出他们是线性和非线性组合的链。<br>本教程旨在让您开始编写深度学习的代码和让你知道这些必备知识。</p><p>请注意，这是关于模型而不是数据。对于所有的模型，我们只创建一个小维度的小的测试样例，以便您可以看到权重在它训练时是如何变化的。如果有一些真实数据你想去尝试，你应该能够撕掉这个笔记上的任何模型，并使用他们。</p><h1 id="介绍-PyTorch"><a href="#介绍-PyTorch" class="headerlink" title="介绍 PyTorch"></a>介绍 PyTorch</h1><h2 id="介绍-Torch-的张量库"><a href="#介绍-Torch-的张量库" class="headerlink" title="介绍 Torch 的张量库"></a>介绍 Torch 的张量库</h2><p>所有深度学习都是基于张量计算，这是矩阵的推广，它的维度可以超过两维。我们将在后面深入地看到这究竟意味着什么。首先，让我们看看我们可以使用张量做什么。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此教程翻译自&lt;a href=&quot;http://pytorch.org/tutorials/beginner/deep_learning_nlp_tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
      <category term="PyTorch" scheme="http://yoursite.com/categories/PyTorch/"/>
    
    
      <category term="PyTorch" scheme="http://yoursite.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>Learn Progress</title>
    <link href="http://yoursite.com/2018/01/20/Learn-Progress/"/>
    <id>http://yoursite.com/2018/01/20/Learn-Progress/</id>
    <published>2018-01-20T05:14:25.000Z</published>
    <updated>2018-01-20T05:21:08.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标检测-Object-Detection"><a href="#目标检测-Object-Detection" class="headerlink" title="目标检测(Object Detection)"></a>目标检测(Object Detection)</h1><ul><li><p>R-CNN 论文笔记 </p><ul><li>论文<a href="https://dl.dropboxusercontent.com/s/293tu0hh9ww08co/r-cnn-cvpr.pdf?dl=0" target="_blank" rel="noopener">《Rich feature hierarchies for accurate object detection and semantic segmentation》</a></li><li><a href="http://www.cnblogs.com/kingstrong/p/4969472.html" target="_blank" rel="noopener">http://www.cnblogs.com/kingstrong/p/4969472.html</a></li><li><a href="http://blog.gater.vip/articles/2015/11/02/1478607351098.html" target="_blank" rel="noopener">http://blog.gater.vip/articles/2015/11/02/1478607351098.html</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目标检测-Object-Detection&quot;&gt;&lt;a href=&quot;#目标检测-Object-Detection&quot; class=&quot;headerlink&quot; title=&quot;目标检测(Object Detection)&quot;&gt;&lt;/a&gt;目标检测(Object Detection)
      
    
    </summary>
    
      <category term="Tutorial" scheme="http://yoursite.com/categories/Tutorial/"/>
    
    
      <category term="Tutorial" scheme="http://yoursite.com/tags/Tutorial/"/>
    
  </entry>
  
</feed>
